import { WhaleApiClient } from '../whale.api.client';
import { ApiPagedResponse } from '../whale.api.response';
/**
 * DeFi whale endpoint for poolpair related services.
 */
export declare class PoolPairs {
    private readonly client;
    constructor(client: WhaleApiClient);
    /**
     * List pool pairs
     *
     * @param {number} size of PoolPairData balance to query
     * @param {string} next set of PoolPairData
     * @return {Promise<ApiPagedResponse<PoolPairData>>}
     */
    list(size?: number, next?: string): Promise<ApiPagedResponse<PoolPairData>>;
    /**
     * Get pool pair
     *
     * @param {string} id
     * @return {Promise<PoolPairData>}
     */
    get(id: string): Promise<PoolPairData>;
    /**
     * List pool swaps
     *
     * @param {string} id poolpair id
     * @param {number} size of PoolSwap to query
     * @param {string} next set of PoolSwap
     * @return {Promise<ApiPagedResponse<PoolSwapData>>}
     */
    listPoolSwaps(id: string, size?: number, next?: string): Promise<ApiPagedResponse<PoolSwapData>>;
    /**
     * List pool swaps with from/to
     *
     * @param {string} id poolpair id
     * @param {number} [size=10] of PoolSwap to query, max of 20 per page
     * @param {string} next set of PoolSwap
     * @return {Promise<ApiPagedResponse<PoolSwapData>>}
     */
    listPoolSwapsVerbose(id: string, size?: number, next?: string): Promise<ApiPagedResponse<PoolSwapData>>;
    /**
     * List pool swap aggregates
     *
     * @param {string} id poolpair id
     * @param {PoolSwapAggregatedInterval} interval interval
     * @param {number} size of PoolSwap to query
     * @param {string} next set of PoolSwap
     * @return {Promise<ApiPagedResponse<PoolSwapAggregatedData>>}
     */
    listPoolSwapAggregates(id: string, interval: PoolSwapAggregatedInterval, size?: number, next?: string): Promise<ApiPagedResponse<PoolSwapAggregatedData>>;
    /**
     * Get all swappable tokens for a given token
     * @param {string} tokenId
     * @return {Promise<AllSwappableTokensResult>}
     */
    getSwappableTokens(tokenId: string): Promise<AllSwappableTokensResult>;
    /**
     * Get the best (estimated) swap path from one token to another
     * @param {string} fromTokenId
     * @param {string} toTokenId
     * @return {Promise<BestSwapPathResult>}
     */
    getBestPath(fromTokenId: string, toTokenId: string): Promise<BestSwapPathResult>;
    /**
     * Get all possible swap paths from one token to another
     * @param {string} fromTokenId
     * @param {string} toTokenId
     * @return {Promise<SwapPathsResult>}
     */
    getAllPaths(fromTokenId: string, toTokenId: string): Promise<SwapPathsResult>;
    /**
     * Get all dex prices denominated in a given token
     * @param {string} [denomination='dUSD'] denomination
     */
    listDexPrices(denomination: string): Promise<DexPricesResult>;
}
export interface PoolPairData {
    id: string;
    symbol: string;
    displaySymbol: string;
    name: string;
    status: boolean;
    tokenA: {
        id: string;
        symbol: string;
        displaySymbol: string;
        reserve: string;
        blockCommission: string;
        fee?: {
            pct?: string;
            inPct?: string;
            outPct?: string;
        };
    };
    tokenB: {
        id: string;
        symbol: string;
        displaySymbol: string;
        reserve: string;
        blockCommission: string;
        fee?: {
            pct?: string;
            inPct?: string;
            outPct?: string;
        };
    };
    priceRatio: {
        ab: string;
        ba: string;
    };
    commission: string;
    totalLiquidity: {
        token: string;
        usd?: string;
    };
    tradeEnabled: boolean;
    ownerAddress: string;
    rewardPct: string;
    rewardLoanPct: string;
    customRewards?: string[];
    creation: {
        tx: string;
        height: number;
    };
    apr?: {
        total: number;
        reward: number;
        commission: number;
    };
    volume?: {
        d30: number;
        h24: number;
    };
}
/**
 * @deprecated use PoolSwapData instead
 */
export declare type PoolSwap = PoolSwapData;
/**
 * @deprecated use PoolSwapAggregatedData instead
 */
export declare type PoolSwapAggregated = PoolSwapAggregatedData;
export declare enum SwapType {
    BUY = "BUY",
    SELL = "SELL"
}
export interface PoolSwapData {
    id: string;
    sort: string;
    txid: string;
    txno: number;
    poolPairId: string;
    fromAmount: string;
    fromTokenId: number;
    /**
     * To handle for optional value as Whale service might fail to resolve when indexing
     */
    from?: PoolSwapFromToData;
    /**
     * To handle for optional value as Whale service might fail to resolve when indexing
     */
    to?: PoolSwapFromToData;
    /**
     * To handle for optional value as Whale service might fail to resolve when indexing
     */
    type?: SwapType;
    block: {
        hash: string;
        height: number;
        time: number;
        medianTime: number;
    };
}
export interface PoolSwapFromToData {
    address: string;
    amount: string;
    symbol: string;
    displaySymbol: string;
}
export interface PoolSwapAggregatedData {
    id: string;
    key: string;
    bucket: number;
    aggregated: {
        amounts: Record<string, string>;
        /**
         * aggregated value in USD at current dex prices
         */
        usd: number;
    };
    block: {
        medianTime: number;
    };
}
export declare enum PoolSwapAggregatedInterval {
    ONE_HOUR = 3600,
    ONE_DAY = 86400
}
export interface AllSwappableTokensResult {
    fromToken: TokenIdentifier;
    swappableTokens: TokenIdentifier[];
}
export interface EstimatedDexFeesInPct {
    ab: string;
    ba: string;
}
export interface BestSwapPathResult {
    fromToken: TokenIdentifier;
    toToken: TokenIdentifier;
    bestPath: SwapPathPoolPair[];
    estimatedReturn: string;
    estimatedReturnLessDexFees: string;
}
export interface SwapPathsResult {
    fromToken: TokenIdentifier;
    toToken: TokenIdentifier;
    paths: SwapPathPoolPair[][];
}
export interface SwapPathPoolPair {
    poolPairId: string;
    symbol: string;
    tokenA: TokenIdentifier;
    tokenB: TokenIdentifier;
    priceRatio: {
        ab: string;
        ba: string;
    };
    estimatedDexFeesInPct?: EstimatedDexFeesInPct;
}
export interface TokenIdentifier {
    id: string;
    symbol: string;
    displaySymbol: string;
}
export interface DexPricesResult {
    denomination: TokenIdentifier;
    dexPrices: {
        [symbol: string]: DexPrice;
    };
}
export interface DexPrice {
    token: TokenIdentifier;
    denominationPrice: string;
}
//# sourceMappingURL=poolpairs.d.ts.map