"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletClassic = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_transaction_signature_1 = require("@defichain/jellyfish-transaction-signature");
/**
 * WalletClassic extends WalletEllipticPair with a simple classic implementation.
 *
 * Single elliptic pair wallet.
 */
class WalletClassic {
    constructor(ellipticPair) {
        this.ellipticPair = ellipticPair;
    }
    /**
     * @return {Promise<Buffer>} compressed public key
     */
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.ellipticPair.publicKey();
        });
    }
    /**
     * @return {Promise<Buffer>} privateKey
     */
    privateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.ellipticPair.privateKey();
        });
    }
    /**
     * @param {Buffer} hash to sign
     * @return {Buffer} signature in DER format, SIGHASHTYPE not included
     * @see https://tools.ietf.org/html/rfc6979
     * @see https://github.com/bitcoin/bitcoin/pull/13666
     */
    sign(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.ellipticPair.sign(hash);
        });
    }
    /**
     * @param {Buffer} hash to verify with signature
     * @param {Buffer} derSignature of the hash in encoded with DER, SIGHASHTYPE must not be included
     * @return {boolean} validity of signature of the hash
     */
    verify(hash, derSignature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.ellipticPair.verify(hash, derSignature);
        });
    }
    /**
     * WalletClassic transaction signing.
     *
     * @param {Transaction} transaction to sign
     * @param {Vout[]} prevouts of the transaction to fund this transaction
     * @return {TransactionSegWit} a signed transaction
     */
    signTx(transaction, prevouts) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield jellyfish_transaction_signature_1.TransactionSigner.signPrevoutsWithEllipticPairs(transaction, prevouts, prevouts.map(() => this), {
                sigHashType: jellyfish_transaction_1.SIGHASH.ALL
            });
        });
    }
}
exports.WalletClassic = WalletClassic;
//# sourceMappingURL=classic.js.map