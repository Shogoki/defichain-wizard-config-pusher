/// <reference types="node" />
import { WalletHdNodeProvider } from '@defichain/jellyfish-wallet';
import * as bip32 from 'bip32';
import { Bip32Options, MnemonicHdNode } from '@defichain/jellyfish-wallet-mnemonic';
import { PrivateKeyEncryption } from './encryption';
/**
 * EncryptedMnemonicHdNode extends MnemonicHdNode to implement promise-based privKey resolution.
 * This allows latent based implementation where privKey need to be decrypted.
 *
 * Prior Art:
 * - BIP32 Hierarchical Deterministic Wallets
 * - BIP39 Mnemonic code for generating deterministic keys
 * - BIP44 Multi-Account Hierarchy for Deterministic Wallets
 */
export declare class EncryptedMnemonicHdNode extends MnemonicHdNode {
    private readonly rootPubKey;
    private readonly promisePrivKey;
    constructor(path: string, chainCode: Buffer, options: Bip32Options, rootPubKey: Buffer, promisePrivKey: () => Promise<Buffer>);
    /**
     * Latent based implementation where privKey need to be resolved via a promise.
     */
    protected deriveNode(): Promise<bip32.BIP32Interface>;
    /**
     * @return Promise<Buffer> compressed public key
     */
    publicKey(): Promise<Buffer>;
}
/**
 * EncryptedProviderData data encoded as hex.
 */
export interface EncryptedProviderData {
    pubKey: string;
    chainCode: string;
    encryptedPrivKey: string;
}
/**
 * Promise based Passphrase Prompt from EncryptedHdNodeProvider.
 * For on-demand request passphrase to decrypt EncryptedProviderData.
 */
export declare type PromptPassphrase = () => Promise<string>;
/**
 * EncryptedHdNodeProvider implements MnemonicHdNode implementation privateKey on-demand decryption via scrypt.
 *
 */
export declare class EncryptedHdNodeProvider implements WalletHdNodeProvider<EncryptedMnemonicHdNode> {
    private readonly data;
    private readonly options;
    private readonly scrypt;
    private readonly promptPassphrase;
    private constructor();
    /**
     * @param {string} path to derive with on-demand node
     * @return EncryptedMnemonicHdNode with promisePrivKey that will only be resolved and decrypted when privateKey is accessed
     */
    derive(path: string): EncryptedMnemonicHdNode;
    /**
     * @param {string[]} words to convert into EncryptedProviderData
     * @param {Bip32Options} options
     * @param {string} scrypt to encrypt mnemonic words
     * @param {string} passphrase to encrypt mnemonic words with
     * @return EncryptedProviderData with unencrypted "pubKey & chainCode" and scrypt encoded 'encryptedPrivKey'
     */
    static wordsToEncryptedData(words: string[], options: Bip32Options, scrypt: PrivateKeyEncryption, passphrase: string): Promise<EncryptedProviderData>;
    /**
     * @param {EncryptedProviderData} data with unencrypted "pubKey & chainCode" and scrypt encoded 'encryptedPrivKey'
     * @param {Bip32Options} options
     * @param {string} scrypt to decrypt encrypted private key
     * @param {PromptPassphrase} promptPassphrase for on-demand request passphrase to decrypt encrypted private key
     * @return EncryptedHdNodeProvider
     */
    static init(data: EncryptedProviderData, options: Bip32Options, scrypt: PrivateKeyEncryption, promptPassphrase: PromptPassphrase): EncryptedHdNodeProvider;
}
//# sourceMappingURL=hd_node.d.ts.map