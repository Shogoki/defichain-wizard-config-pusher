/// <reference types="node" />
import { Scrypt } from './scrypt';
export declare class EncryptedData {
    readonly prefix: number;
    readonly type: number;
    readonly flags: number;
    readonly hash: Buffer;
    readonly encryptedFirstHalf: Buffer;
    readonly encryptedSecondHalf: Buffer;
    /**
     * Total = 7 + 2n bytes
     *
     * @param {number} prefix - 0x01
     * @param {number} type - 0x42 or 0x43 (only 0x42 for now)
     * @param {number} flags - 1 byte (only true for 2 most significant bit for now)
     * @param {Buffer} hash - 4 bytes, checksum and salt
     * @param {Buffer} encryptedFirstHalf - n bytes
     * @param {Buffer} encryptedSecondHalf - n bytes
     */
    constructor(prefix: number, type: number, flags: number, hash: Buffer, encryptedFirstHalf: Buffer, encryptedSecondHalf: Buffer);
    encode(): string;
    static decode(encoded: string): EncryptedData;
}
export declare class PrivateKeyEncryption {
    private readonly scrypt;
    private readonly rng;
    /**
     * @param {Scrypt} scrypt to convert a utf8 string into a secret, cryptographically secured
     * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required for IV
     */
    constructor(scrypt?: Scrypt, rng?: (numOfBytes: number) => Buffer);
    /**
     * To encrypt `data` with a `passphrase` derived secret (derivation based on provided `ScryptProvider`)
     * @see https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki#Encryption_when_EC_multiply_flag_is_not_used for encryption methodology
     *
     * @param {Buffer} data data with even number length
     * @param {string} passphrase to derived encryption secret, utf8 string in normalization format C
     */
    encrypt(data: Buffer, passphrase: string): Promise<EncryptedData>;
    /**
     * To decrypt raw data
     *
     * @param {string} encrypted to decrypt
     * @param {string} passphrase to decrypted data, utf8 string in normalization format C
     * @returns {Promise<Buffer>} null if no data found in storage
     * @throws Error InvalidPassphrase if passphrase is invalid (decrypted value has no matching hash)
     */
    decrypt(encrypted: string, passphrase: string): Promise<Buffer>;
}
//# sourceMappingURL=encryption.d.ts.map