"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedHdNodeProvider = exports.EncryptedMnemonicHdNode = void 0;
const bip32 = __importStar(require("bip32"));
const jellyfish_wallet_mnemonic_1 = require("@defichain/jellyfish-wallet-mnemonic");
/**
 * EncryptedMnemonicHdNode extends MnemonicHdNode to implement promise-based privKey resolution.
 * This allows latent based implementation where privKey need to be decrypted.
 *
 * Prior Art:
 * - BIP32 Hierarchical Deterministic Wallets
 * - BIP39 Mnemonic code for generating deterministic keys
 * - BIP44 Multi-Account Hierarchy for Deterministic Wallets
 */
class EncryptedMnemonicHdNode extends jellyfish_wallet_mnemonic_1.MnemonicHdNode {
    constructor(path, chainCode, options, rootPubKey, promisePrivKey) {
        super(path, Buffer.alloc(0), chainCode, options);
        this.rootPubKey = rootPubKey;
        this.promisePrivKey = promisePrivKey;
    }
    /**
     * Latent based implementation where privKey need to be resolved via a promise.
     */
    deriveNode() {
        return __awaiter(this, void 0, void 0, function* () {
            const rootPrivKey = yield this.promisePrivKey();
            return bip32.fromPrivateKey(rootPrivKey, this.chainCode, this.options)
                .derivePath(this.path);
        });
    }
    /**
     * @return Promise<Buffer> compressed public key
     */
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return bip32.fromPublicKey(this.rootPubKey, this.chainCode, this.options)
                .derivePath(this.path)
                .publicKey;
        });
    }
}
exports.EncryptedMnemonicHdNode = EncryptedMnemonicHdNode;
/**
 * EncryptedHdNodeProvider implements MnemonicHdNode implementation privateKey on-demand decryption via scrypt.
 *
 */
class EncryptedHdNodeProvider {
    constructor(data, options, scrypt, promptPassphrase) {
        this.data = data;
        this.options = options;
        this.scrypt = scrypt;
        this.promptPassphrase = promptPassphrase;
    }
    /**
     * @param {string} path to derive with on-demand node
     * @return EncryptedMnemonicHdNode with promisePrivKey that will only be resolved and decrypted when privateKey is accessed
     */
    derive(path) {
        const encrypted = this.data.encryptedPrivKey;
        const rootPubKey = Buffer.from(this.data.pubKey, 'hex');
        const chainCode = Buffer.from(this.data.chainCode, 'hex');
        const promisePrivKey = () => __awaiter(this, void 0, void 0, function* () {
            const passphrase = yield this.promptPassphrase();
            return yield this.scrypt.decrypt(encrypted, passphrase);
        });
        return new EncryptedMnemonicHdNode(path, chainCode, this.options, rootPubKey, promisePrivKey);
    }
    /**
     * @param {string[]} words to convert into EncryptedProviderData
     * @param {Bip32Options} options
     * @param {string} scrypt to encrypt mnemonic words
     * @param {string} passphrase to encrypt mnemonic words with
     * @return EncryptedProviderData with unencrypted "pubKey & chainCode" and scrypt encoded 'encryptedPrivKey'
     */
    static wordsToEncryptedData(words, options, scrypt, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonic = jellyfish_wallet_mnemonic_1.MnemonicHdNodeProvider.wordsToData(words, options);
            const privKey = Buffer.from(mnemonic.privKey, 'hex');
            const chainCode = Buffer.from(mnemonic.chainCode, 'hex');
            const root = bip32.fromPrivateKey(privKey, chainCode, options);
            const encrypted = yield scrypt.encrypt(privKey, passphrase);
            return {
                pubKey: root.publicKey.toString('hex'),
                chainCode: mnemonic.chainCode,
                encryptedPrivKey: encrypted.encode()
            };
        });
    }
    /**
     * @param {EncryptedProviderData} data with unencrypted "pubKey & chainCode" and scrypt encoded 'encryptedPrivKey'
     * @param {Bip32Options} options
     * @param {string} scrypt to decrypt encrypted private key
     * @param {PromptPassphrase} promptPassphrase for on-demand request passphrase to decrypt encrypted private key
     * @return EncryptedHdNodeProvider
     */
    static init(data, options, scrypt, promptPassphrase) {
        return new EncryptedHdNodeProvider(data, options, scrypt, promptPassphrase);
    }
}
exports.EncryptedHdNodeProvider = EncryptedHdNodeProvider;
//# sourceMappingURL=hd_node.js.map