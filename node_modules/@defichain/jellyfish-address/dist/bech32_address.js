"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bech32Address = void 0;
const bech32_1 = require("bech32");
const address_1 = require("./address");
class Bech32Address extends address_1.Address {
    constructor(network, utf8String, valid, addressType) {
        super(network, utf8String.toLowerCase(), valid, addressType);
    }
    validators() {
        return [
            () => (new RegExp(`^${this.getHrp()}`).test(this.utf8String)),
            () => {
                const charset = '[02-9ac-hj-np-z]'; // 0-9, a-z, and reject: [1, b, i, o]
                const arr = this.utf8String.split('1');
                const excludeHrp = arr[arr.length - 1];
                const regex = new RegExp(`${charset}{${excludeHrp.length}}$`);
                return regex.test(excludeHrp);
            }
        ];
    }
    getHrp() {
        return this.network.bech32.hrp;
    }
    static fromAddress(network, raw, AddressClass) {
        let valid;
        let prefix;
        let data = '';
        try {
            const decoded = bech32_1.bech32.decode(raw);
            valid = true;
            prefix = decoded.prefix;
            const trimmedVersion = decoded.words.slice(1);
            data = Buffer.from(bech32_1.bech32.fromWords(trimmedVersion)).toString('hex');
            if (prefix !== network.bech32.hrp) {
                valid = false;
            }
        }
        catch (e) {
            valid = false;
        }
        return new AddressClass(network, raw, data, valid);
    }
}
exports.Bech32Address = Bech32Address;
Bech32Address.MAX_LENGTH = 90;
Bech32Address.MAX_HUMAN_READABLE_LENGTH = 83;
//# sourceMappingURL=bech32_address.js.map