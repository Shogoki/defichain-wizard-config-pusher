"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2SH = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const base58_address_1 = require("./base58_address");
class P2SH extends base58_address_1.Base58Address {
    constructor(network, utf8String, hex, validated = false) {
        super(network, utf8String, hex, validated, 'P2SH');
    }
    getPrefix() {
        return this.network.scriptHashPrefix;
    }
    getScript() {
        if (!this.valid) {
            this.validate();
        }
        if (!this.valid) {
            throw new Error('InvalidDefiAddress');
        }
        return {
            stack: [
                jellyfish_transaction_1.OP_CODES.OP_HASH160,
                new jellyfish_transaction_1.OP_PUSHDATA(Buffer.from(this.hex, 'hex'), 'little'),
                jellyfish_transaction_1.OP_CODES.OP_EQUAL
            ]
        };
    }
    static to(net, h160) {
        if (h160.length !== base58_address_1.Base58Address.DATA_HEX_LENGTH) {
            throw new Error('InvalidDataLength');
        }
        const network = typeof net === 'string' ? jellyfish_network_1.getNetwork(net) : net;
        const address = jellyfish_crypto_1.Bs58.fromHash160(h160, network.scriptHashPrefix);
        return new P2SH(network, address, h160, true);
    }
}
exports.P2SH = P2SH;
P2SH.SCRIPT_HASH_LENGTH = 50; // 25 bytes, 50 char
//# sourceMappingURL=p2sh.js.map