"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2WPKH = void 0;
const bech32_1 = require("bech32");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const bech32_address_1 = require("./bech32_address");
class P2WPKH extends bech32_address_1.Bech32Address {
    constructor(network, utf8String, pubKeyHash, validated = false) {
        super(network, utf8String, validated, 'P2WPKH');
        this.pubKeyHash = pubKeyHash;
    }
    validators() {
        const rawAdd = this.utf8String;
        return [
            ...super.validators(),
            () => (rawAdd.length <= P2WPKH.LENGTH_EXCLUDE_HRP + this.getHrp().length + 1),
            () => (rawAdd.length === P2WPKH.LENGTH_EXCLUDE_HRP + this.getHrp().length + 1),
            () => (this.pubKeyHash.length === P2WPKH.PUB_KEY_HASH_LENGTH)
        ];
    }
    getHrp() {
        return this.network.bech32.hrp;
    }
    getScript() {
        if (!this.valid) {
            this.validate();
        }
        if (!this.valid) {
            throw new Error('InvalidDefiAddress');
        }
        return {
            stack: [
                jellyfish_transaction_1.OP_CODES.OP_0,
                new jellyfish_transaction_1.OP_PUSHDATA(Buffer.from(this.pubKeyHash, 'hex'), 'little')
            ]
        };
    }
    /**
     * @param net network
     * @param hex data, public key hash (20 bytes, 40 characters)
     * @param witnessVersion default 0
     * @returns
     */
    static to(net, h160, witnessVersion = 0x00) {
        const network = typeof net === 'string' ? jellyfish_network_1.getNetwork(net) : net;
        if (h160.length !== P2WPKH.PUB_KEY_HASH_LENGTH) {
            throw new Error('InvalidPubKeyHashLength');
        }
        const numbers = Buffer.from(h160, 'hex');
        const fiveBitsWords = bech32_1.bech32.toWords(numbers);
        const includeVersion = [witnessVersion, ...fiveBitsWords];
        const utf8 = bech32_1.bech32.encode(network.bech32.hrp, includeVersion);
        return new P2WPKH(network, utf8, h160, true);
    }
}
exports.P2WPKH = P2WPKH;
P2WPKH.SAMPLE = 'bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq';
P2WPKH.LENGTH_EXCLUDE_HRP = 39; // exclude hrp and separator
P2WPKH.PUB_KEY_HASH_LENGTH = 40;
//# sourceMappingURL=p2wpkh.js.map