"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeFiAddress = void 0;
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const address_1 = require("./address");
const base58_address_1 = require("./base58_address");
const bech32_address_1 = require("./bech32_address");
const p2pkh_1 = require("./p2pkh");
const p2sh_1 = require("./p2sh");
const p2wsh_1 = require("./p2wsh");
const p2wpkh_1 = require("./p2wpkh");
__exportStar(require("./address"), exports);
__exportStar(require("./base58_address"), exports);
__exportStar(require("./bech32_address"), exports);
__exportStar(require("./p2pkh"), exports);
__exportStar(require("./p2sh"), exports);
__exportStar(require("./p2wpkh"), exports);
__exportStar(require("./p2wsh"), exports);
/**
 * When insist to use the "network" decoded from raw address, instead of passing one based on running application environment
 * @param address raw human readable address (utf-8)
 * @returns DefiAddress or a child class
 *
 * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
 */
function guess(address) {
    const networks = ['mainnet', 'testnet', 'regtest'];
    const defaultOne = new address_1.UnknownTypeAddress(jellyfish_network_1.getNetwork('mainnet'), address);
    for (let i = 0; i < networks.length; i += 1) {
        const guessed = from(networks[i], address);
        if (guessed.valid) {
            return guessed;
        }
    }
    return defaultOne;
}
/**
 * @param net to be validated against the decoded one from the raw address
 * @param address raw human readable address (utf-8)
 * @returns DefiAddress or a child class
 *
 * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
 */
function from(net, address) {
    const network = jellyfish_network_1.getNetwork(net);
    const possible = new Map();
    possible.set('Unknown', new address_1.UnknownTypeAddress(network, address));
    possible.set('P2PKH', base58_address_1.Base58Address.fromAddress(network, address, p2pkh_1.P2PKH));
    possible.set('P2SH', base58_address_1.Base58Address.fromAddress(network, address, p2sh_1.P2SH));
    possible.set('P2WPKH', bech32_address_1.Bech32Address.fromAddress(network, address, p2wpkh_1.P2WPKH));
    possible.set('P2WSH', bech32_address_1.Bech32Address.fromAddress(network, address, p2wsh_1.P2WSH));
    possible.forEach(each => each.validate());
    let valid;
    possible.forEach(each => {
        if (each.valid) {
            valid = each;
        }
    });
    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    if (valid) {
        // find if any has all validator passed
        return valid;
    }
    // else select the closest guess (most validator passed)
    // default, when non have validator passed
    let highestKey = 'Unknown';
    let highestCount = 0;
    possible.forEach((val, key) => {
        if (val.validatorPassed > highestCount) {
            highestKey = key;
            highestCount = val.validatorPassed;
        }
    });
    return possible.get(highestKey);
}
/**
 * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
 */
exports.DeFiAddress = {
    /**
     * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
     */
    guess,
    /**
     * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
     */
    from
};
__exportStar(require("./script"), exports);
//# sourceMappingURL=index.js.map