"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBase58Check = exports.toBase58Check = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const bs58_1 = __importDefault(require("bs58"));
/**
 * @param {Buffer} bytes 21 bytes
 */
function _checksum(bytes) {
    return jellyfish_crypto_1.SHA256(jellyfish_crypto_1.SHA256(bytes)).slice(0, 4);
}
/**
 * Base58 with Checksum for P2SH and P2PKH addresses.
 *
 * @param {Buffer} buffer 20 bytes Buffer (Hash160)
 * @param {number} prefix 1 byte length network prefix
 * @returns string base58check encoded address
 */
function toBase58Check(buffer, prefix) {
    if (buffer.length !== 20) {
        throw new Error('Base58Check buffer length must be 20');
    }
    const prefixed = Buffer.from([
        ...Buffer.alloc(1, prefix),
        ...buffer
    ]);
    const prefixedChecked = Buffer.from([
        ...prefixed,
        ..._checksum(prefixed)
    ]);
    return bs58_1.default.encode(prefixedChecked);
}
exports.toBase58Check = toBase58Check;
function fromBase58Check(address) {
    const buffer = bs58_1.default.decode(address);
    if (buffer.length !== 25) {
        throw new Error('Invalid Base58Check address, length != 25');
    }
    const prefixed = buffer.slice(0, 21);
    const checksum = buffer.slice(21, 25);
    const expectedChecksum = _checksum(prefixed);
    if (checksum.compare(expectedChecksum) !== 0) {
        throw new Error('Invalid Base58Check address, checksum invalid');
    }
    return {
        prefix: prefixed[0],
        buffer: prefixed.slice(1, 21)
    };
}
exports.fromBase58Check = fromBase58Check;
//# sourceMappingURL=Base58Check.js.map