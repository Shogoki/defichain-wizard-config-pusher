"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromScriptHex = exports.fromScript = exports.fromAddress = exports.AddressType = void 0;
const smart_buffer_1 = require("smart-buffer");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const P2WPKH_1 = require("./P2WPKH");
const P2WSH_1 = require("./P2WSH");
const P2SH_1 = require("./P2SH");
const P2PKH_1 = require("./P2PKH");
const Bech32_1 = require("./Bech32");
const Base58Check_1 = require("./Base58Check");
/**
 * Known Address Types
 */
var AddressType;
(function (AddressType) {
    /**
     * Pay to Witness Public Key Hash
     * Native SEGWIT with Bech32
     */
    AddressType["P2WPKH"] = "P2WPKH";
    /**
     * Pay to Witness Script Hash
     * Native SEGWIT with Bech32
     */
    AddressType["P2WSH"] = "P2WSH";
    /**
     * Pay to Script Hash
     */
    AddressType["P2SH"] = "P2SH";
    /**
     * Pay to Public Key Hash
     * Also known as legacy
     */
    AddressType["P2PKH"] = "P2PKH";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Convert an address to a script, this operation requires the network to be known.
 * A script is network agnostic while the address is prefixed with the network's unique human readable part.
 *
 * @param {string} address to convert into Script
 * @param {NetworkName} network to prefix human readable part of the address
 * @return {DecodedAddress | undefined} DecodedAddress if is a recognizable, undefined if fail to parse
 */
function fromAddress(address, network) {
    try {
        const decodedBech32 = Bech32_1.fromBech32(address);
        const p2wpkh = P2WPKH_1.fromBech32P2WPKH(decodedBech32, network);
        if (p2wpkh !== undefined) {
            return {
                type: AddressType.P2WPKH,
                address: address,
                script: p2wpkh,
                network: network
            };
        }
        const p2wsh = P2WSH_1.fromBech32P2WSH(decodedBech32, network);
        if (p2wsh !== undefined) {
            return {
                type: AddressType.P2WSH,
                address: address,
                script: p2wsh,
                network: network
            };
        }
    }
    catch (err) {
    }
    try {
        const decodedBase58Check = Base58Check_1.fromBase58Check(address);
        const p2pkh = P2PKH_1.fromBase58CheckP2PKH(decodedBase58Check, network);
        if (p2pkh !== undefined) {
            return {
                type: AddressType.P2PKH,
                address: address,
                script: p2pkh,
                network: network
            };
        }
        const p2sh = P2SH_1.fromBase58CheckP2SH(decodedBase58Check, network);
        if (p2sh !== undefined) {
            return {
                type: AddressType.P2SH,
                address: address,
                script: p2sh,
                network: network
            };
        }
    }
    catch (err) {
    }
    return undefined;
}
exports.fromAddress = fromAddress;
/**
 * Convert a script to address, this operation requires the network to be known.
 * A script is network agnostic while the address is prefixed with the network's unique human readable part.
 *
 * @param {Script} script to convert into address
 * @param {NetworkName} network to prefix human readable part of the address
 * @return {DecodedAddress | undefined} DecodedAddress if is a recognizable, undefined if fail to parse
 */
function fromScript(script, network) {
    const p2wpkh = P2WPKH_1.fromScriptP2WPKH(script, network);
    if (p2wpkh !== undefined) {
        return {
            type: AddressType.P2WPKH,
            address: p2wpkh,
            script: script,
            network: network
        };
    }
    const p2wsh = P2WSH_1.fromScriptP2WSH(script, network);
    if (p2wsh !== undefined) {
        return {
            type: AddressType.P2WSH,
            address: p2wsh,
            script: script,
            network: network
        };
    }
    const p2pkh = P2PKH_1.fromScriptP2PKH(script, network);
    if (p2pkh !== undefined) {
        return {
            type: AddressType.P2PKH,
            address: p2pkh,
            script: script,
            network: network
        };
    }
    const p2sh = P2SH_1.fromScriptP2SH(script, network);
    if (p2sh !== undefined) {
        return {
            type: AddressType.P2SH,
            address: p2sh,
            script: script,
            network: network
        };
    }
    return undefined;
}
exports.fromScript = fromScript;
/**
 * Convert a script to address, this operation requires the network to be known.
 * A script is network agnostic while the address is prefixed with the network's unique human readable part.
 *
 * @param {string} hex of the script to convert into address, without VarUInt length
 * @param {NetworkName} network to prefix human readable part of the address
 * @return {DecodedAddress | undefined} DecodedAddress if is a recognizable, undefined if fail to parse
 */
function fromScriptHex(hex, network) {
    const buffer = Buffer.from(hex, 'hex');
    const script = {
        stack: jellyfish_transaction_1.toOPCodes(smart_buffer_1.SmartBuffer.fromBuffer(buffer))
    };
    return fromScript(script, network);
}
exports.fromScriptHex = fromScriptHex;
//# sourceMappingURL=index.js.map