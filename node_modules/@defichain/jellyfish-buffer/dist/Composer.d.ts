import BigNumber from 'bignumber.js';
import { SmartBuffer } from 'smart-buffer';
export interface BufferComposer {
    fromBuffer: (buffer: SmartBuffer) => void;
    toBuffer: (buffer: SmartBuffer) => void;
}
/**
 * A highly composable buffer, by defining a list of composer, it allows bi-directional buffer to object serialization.
 * In short, you compose from a Buffer to Object or an Object to a Buffer. Little endian by design.
 *
 * It is also deeply recursive by default allow cascading object composing.
 */
export declare abstract class ComposableBuffer<T> implements BufferComposer {
    protected readonly data: T;
    abstract composers(data: T): BufferComposer[];
    /**
     * @param data to create ComposableBuffer holder, nothing is done/composed yet.
     */
    constructor(data: T);
    /**
     * @param {SmartBuffer} buffer to compose into Object
     */
    constructor(buffer: SmartBuffer);
    /**
     * For typescript type checking
     */
    constructor(data: SmartBuffer | T);
    fromBuffer(buffer: SmartBuffer): void;
    toBuffer(buffer: SmartBuffer): void;
    toHex(): string;
    /**
     * Deeply toObject() mapper.
     * This unwrap the data in ComposableBuffer and convert all ComposableBuffer into their raw object.
     * This make it compatible to convert into JSON with JSON.stringify()
     * @return {Object}
     */
    toObject(): any;
    /**
     * @return BufferComposer that does nothing
     */
    static empty(): BufferComposer;
    /**
     * The length of the array is set with CompactSize in the first sequence of 1 - 9 bytes.
     *
     * @param getter to read array of ComposableBuffer Object from to buffer
     * @param setter to set array of ComposableBuffer Object from buffer
     * @param asC map single object into ComposableBuffer Object
     *
     * @see array if length is not given but known
     */
    static compactSizeArray<T>(getter: () => T[], setter: (data: T[]) => void, asC: (data: SmartBuffer | T) => ComposableBuffer<T>): BufferComposer;
    /**
     * The length of the array must be known and given to the composer, use compactSizeArray if length is set as CompactSize.
     *
     * @param getter to read array of ComposableBuffer Object from to buffer
     * @param setter to set array of ComposableBuffer Object from buffer
     * @param asC map single object into ComposableBuffer Object
     * @param getLength of the array
     *
     * @see use compactSizeArray if length is set as CompactSize
     */
    static array<T>(getter: () => T[], setter: (data: T[]) => void, asC: (data: SmartBuffer | T) => ComposableBuffer<T>, getLength: () => number): BufferComposer;
    /**
     * The length depends on the Composable buffer composer configuration
     *
     * @param getter to read single ComposableBuffer Object from to buffer
     * @param setter to set single ComposableBuffer Object from buffer
     * @param asC map object into ComposableBuffer Object
     */
    static single<T>(getter: () => T, setter: (data: T) => void, asC: (data: SmartBuffer | T) => ComposableBuffer<T>): BufferComposer;
    /**
     * HEX String with length specified, encoded into Buffer as the same order of the Hex String.
     * In short this read a hex and push it into the Buffer. It will not re-order the endian.
     *
     * @param length of the bytes to read/set
     * @param getter to read HEX String and write as the same ordered Buffer
     * @param setter to read ordered Buffer and set as the same ordered HEX String
     * @throws Error if length != getter().length in set
     */
    static hex(length: number, getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * HEX String with length specified, encoded into Buffer as the same order of the Hex String.
     * In short this read a hex and push it into the Buffer. It will not re-order the endian.
     *
     * When hex is `undefined` it will write `0x00` signifying zero byte length.
     *
     * @param getter to read HEX String. Writes its length then write the HEX string. Defaults to empty string.
     * @param setter to read ordered Buffer and set as the same ordered HEX String
     */
    static compactSizeOptionalHex(getter: () => string | undefined, setter: (data: string | undefined) => void): BufferComposer;
    /**
     * Same behavior with `hex` when the field is defined
     * `toBuffer` resulted empty SmartBuffer
     *
     * @param length of the bytes to read/set
     * @param getter to read HEX String and write as the same ordered Buffer
     * @param setter to read ordered Buffer and set as the same ordered HEX String
     * @throws Error if getter() is defined && length != getter().length in set
     */
    static optionalHex(length: number, getter: () => string | undefined, setter: (data: string | undefined) => void): BufferComposer;
    /**
     * BE ordered HEX String with length specified, encoded in LE order buffer.
     * Different from BufferComposer.hex, this will reorder the Buffer from LE to BE and BE to LE.
     *
     * @param length of the bytes to read/set
     * @param getter to read BE ordered HEX String and write as LE ordered Buffer
     * @param setter to read LE ordered Buffer and set as BE ordered HEX String
     * @throws Error if length != getter().length in set
     */
    static hexBEBufferLE(length: number, getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * UTF-8 string with length specified, encoded in LE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param length of the bytes to read/set
     * @param getter to read BE ordered String and write as LE ordered Buffer
     * @param setter to read LE ordered Buffer and set as BE ordered String
     * @throws Error if length != getter().length in set
     */
    static utf8LE(length: number, getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * UTF-8 string with length specified, encoded in BE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param length of the bytes to read/set
     * @param getter to read BE ordered String and write as BE ordered Buffer
     * @param setter to read BE ordered Buffer and set as BE ordered String
     * @throws Error if length != getter().length in set
     */
    static utf8BE(length: number, getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * CompactSize sized UTF-8 string, encoded in LE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param getter to read BE ordered String and write as LE ordered Buffer
     * @param setter to read LE ordered Buffer and set as BE ordered String
     */
    static compactSizeUtf8LE(getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * CompactSize sized UTF-8 string, encoded in BE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param getter to read BE ordered String and write as BE ordered Buffer
     * @param setter to read BE ordered Buffer and set as BE ordered String
     */
    static compactSizeUtf8BE(getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * CompactSize sized hex string, encoded into Buffer as the same order of the hex String.
     * In short this read a CompactSize sized hex and push it into the Buffer. It will not re-order the endian.
     *
     * @param getter to read hex String and write as the same ordered Buffer
     * @param setter to read ordered Buffer and set as the same ordered hex String
     */
    static compactSizeHex(getter: () => string, setter: (data: string) => void): BufferComposer;
    /**
     * Unsigned Int8, 1 byte
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uInt8(getter: () => number, setter: (data: number) => any): BufferComposer;
    /**
     * Unsigned Int16, 2 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uInt16(getter: () => number, setter: (data: number) => void): BufferComposer;
    /**
     * Signed Int32, 4 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static int32(getter: () => number, setter: (data: number) => void): BufferComposer;
    /**
     * Unsigned Int32, 4 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uInt32(getter: () => number, setter: (data: number) => void): BufferComposer;
    /**
     * Unsigned BigNumber, 8 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static bigNumberUInt64(getter: () => BigNumber, setter: (data: BigNumber) => void): BufferComposer;
    /**
     * Unsigned satoshi as BigNumber, 8 bytes
     * BigNumber is multiplied/divided by 100,000,000
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static satoshiAsBigNumber(getter: () => BigNumber, setter: (data: BigNumber) => void): BufferComposer;
    /**
     * CompactSize helper method, 1 - 9 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static compactSize(getter: () => number, setter: (data: number) => void): BufferComposer;
    /**
     * VarInt helper method, 1 - 9 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static varInt(getter: () => number, setter: (data: number) => void): BufferComposer;
    /**
     * Imposing mask over bits method, 1 byte
     *
     * @param length of the input array to read/set
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static bitmask1Byte(length: number, getter: () => boolean[], setter: (data: boolean[]) => void): BufferComposer;
    /**
     * Unsigned Boolean 1 byte, 1 = true, 0 = false
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uBool8(getter: () => boolean, setter: (data: boolean) => void): BufferComposer;
    /**
     * Unsigned Boolean 4 bytes, 1 = true, 0 = false
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uBool32(getter: () => boolean, setter: (data: boolean) => void): BufferComposer;
    /**
     * maxPrice as BigNumber, first 8 bytes for integer, last 8 bytes for fraction
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static maxPriceAsBigNumber(getter: () => BigNumber, setter: (data: BigNumber) => void): BufferComposer;
}
//# sourceMappingURL=Composer.d.ts.map