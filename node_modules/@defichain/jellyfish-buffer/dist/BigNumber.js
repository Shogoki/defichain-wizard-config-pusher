"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeBigNumberUInt64 = exports.readBigNumberUInt64 = exports.MAX_INT64 = exports.ONE_HUNDRED_MILLION = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
exports.ONE_HUNDRED_MILLION = new bignumber_js_1.default('100000000');
exports.MAX_INT64 = new bignumber_js_1.default('9223372036854775807');
/**
 * @param {SmartBuffer} buffer to read as unsigned BigNumber (LE)
 * @return BigNumber
 */
function readBigNumberUInt64(buffer) {
    const second = buffer.readUInt32LE();
    const first = buffer.readUInt32LE();
    return new bignumber_js_1.default(first).multipliedBy(0x100000000).plus(second);
}
exports.readBigNumberUInt64 = readBigNumberUInt64;
/**
 * @param {BigNumber} bigNumber
 * @param {SmartBuffer} buffer to write to as unsigned BigNumber (LE)
 */
function writeBigNumberUInt64(bigNumber, buffer) {
    if (bigNumber.isGreaterThan(new bignumber_js_1.default('18446744073709551615'))) {
        throw new Error(`It must be >= 0n and < 2n ** 64n. Received ${bigNumber.toString(10)}`);
    }
    const second = bigNumber.mod(0x100000000);
    const first = bigNumber.minus(second).dividedBy(0x100000000);
    buffer.writeUInt32LE(second.toNumber());
    buffer.writeUInt32LE(first.toNumber());
}
exports.writeBigNumberUInt64 = writeBigNumberUInt64;
//# sourceMappingURL=BigNumber.js.map