"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateWeight = exports.calculateVirtual = exports.calculateFee = exports.calculateFeeP2WPKH = exports.isDustAmount = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const smart_buffer_1 = require("smart-buffer");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
/**
 * Consider dust if output is < 0.00003000
 * This is not the cleanest way to calculate but it's the easiest.
 */
const DUST_AMOUNT = new bignumber_js_1.default('0.00003000');
// const DUST_RELAY_TX_FEE = new BigNumber('0.00003000')
/**
 * A P2PKH witness example for estimating txn size before signing transaction.
 */
const P2WPKH_WITNESS_EXAMPLE = {
    scripts: [
        { hex: '3044022000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000001' },
        { hex: '000000000000000000000000000000000000000000000000000000000000000000' }
    ]
};
/**
 * TODO(jellyfish): consider refactoring this implementation
 *
 * @param {BigNumber} amount that is considered dust if it's too little
 * @return {boolean}
 */
function isDustAmount(amount) {
    return amount.lte(DUST_AMOUNT);
}
exports.isDustAmount = isDustAmount;
/**
 * Calculate fee of a transaction where inputs are all P2WPKH.
 *
 * @param {BigNumber} feeRate in DFI/kb
 * @param {Transaction} transaction
 * @return {BigNumber} fee amount to use for transaction with provided fee rate
 */
function calculateFeeP2WPKH(feeRate, transaction) {
    const witness = transaction.vin.map(_ => P2WPKH_WITNESS_EXAMPLE);
    const size = calculateVirtual(transaction, witness);
    return feeRate.multipliedBy(size).dividedBy(1000);
}
exports.calculateFeeP2WPKH = calculateFeeP2WPKH;
/**
 * @param {BigNumber} feeRate in DFI/kb
 * @param {Transaction} transaction
 * @param {Witness} witness of the transaction, separated to allow unsigned calculation
 * @return {BigNumber} fee amount to use for transaction with provided fee rate
 */
function calculateFee(feeRate, transaction, witness) {
    const size = calculateVirtual(transaction, witness);
    return feeRate.multipliedBy(size).dividedBy(1000);
}
exports.calculateFee = calculateFee;
/**
 * @param {Transaction} transaction
 * @param {Witness} witness of the transaction, separated to allow unsigned calculation
 * @return {number} calculated virtual size of transaction
 */
function calculateVirtual(transaction, witness) {
    return Math.ceil(calculateWeight(transaction, witness) / 4);
}
exports.calculateVirtual = calculateVirtual;
/**
 * @param {Transaction} transaction
 * @param {Witness} witness of the transaction, separated to allow unsigned calculation
 * @return {number} calculated weight of transaction
 */
function calculateWeight(transaction, witness) {
    const base = calculate(transaction);
    const total = calculateWitness({
        version: transaction.version,
        marker: 0x00,
        flag: 0x01,
        vin: transaction.vin,
        vout: transaction.vout,
        lockTime: transaction.lockTime,
        witness: witness
    });
    return base * 3 + total;
}
exports.calculateWeight = calculateWeight;
function calculate(transaction) {
    const buffer = new smart_buffer_1.SmartBuffer();
    new jellyfish_transaction_1.CTransaction(transaction).toBuffer(buffer);
    return buffer.length;
}
function calculateWitness(transaction) {
    const buffer = new smart_buffer_1.SmartBuffer();
    new jellyfish_transaction_1.CTransactionSegWit(transaction).toBuffer(buffer);
    return buffer.length;
}
//# sourceMappingURL=txn_fee.js.map