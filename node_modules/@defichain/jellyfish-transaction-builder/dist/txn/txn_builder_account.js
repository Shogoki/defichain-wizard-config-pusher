"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderAccount = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const txn_builder_error_1 = require("./txn_builder_error");
class TxnBuilderAccount extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Requires UTXO in the same amount + fees to create a transaction.
     *
     * @param {UtxosToAccount} utxosToAccount txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @throws {TxnBuilderError} if 'utxosToAccount.to' length is less than `1`
     * @throws {TxnBuilderError} if 'utxosToAccount.to[any].balances' length is not `1`
     * @throws {TxnBuilderError} if 'utxosToAccount.to[any].balances[0].token' is not `0`\
     * @returns {Promise<TransactionSegWit>}
     */
    utxosToAccount(utxosToAccount, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (utxosToAccount.to.length < 1) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UTXOS_TO_ACCOUNT_OUTPUT, 'Conversion output `utxosToAccount.to` array length must be greater than or equal to one');
            }
            for (let i = 0; i < utxosToAccount.to.length; i++) {
                const sb = utxosToAccount.to[i];
                if (sb.balances.length !== 1) {
                    throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UTXOS_TO_ACCOUNT_OUTPUT, 'Each `utxosToAccount.to` array `balances` array length must be one');
                }
                if (sb.balances[0].token !== 0x00) {
                    throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UTXOS_TO_ACCOUNT_OUTPUT, 'Each `utxosToAccount.to` array `balances[0].token` must be 0x00, only DFI supported');
                }
            }
            const amountToConvert = utxosToAccount.to.reduce((total, dest) => (total.plus(dest.balances[0].amount)), new bignumber_js_1.default(0));
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_UTXOS_TO_ACCOUNT(utxosToAccount), changeScript, amountToConvert);
        });
    }
    /**
     *
     * @param {AccountToUtxos} accountToUtxos txn to create
     * @param {Script} destinationScript vout destination, for both utxos minted and change after deducted fee
     * @throws {TxnBuilderError} if 'accountToUtxos.balances' length is not `1`
     * @throws {TxnBuilderError} if 'accountToUtxos.balances[0].token' is not `0`
     * @throws {TxnBuilderError} if 'accountToUtxos.mintingOutputsStart' is not `2`, vout[0] = DfTx, vout[1] = change, vout[2] = new minted utxos
     * @returns {Promise<TransactionSegWit>}
     */
    accountToUtxos(accountToUtxos, destinationScript) {
        return __awaiter(this, void 0, void 0, function* () {
            if (accountToUtxos.balances.length !== 1) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ACCOUNT_TO_UTXOS_INPUT, 'Conversion output `accountToUtxos.balances` array length must be one');
            }
            if (accountToUtxos.balances[0].token !== 0x00) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ACCOUNT_TO_UTXOS_INPUT, '`accountToUtxos.balances[0].token` must be 0x00, only DFI support');
            }
            if (accountToUtxos.mintingOutputsStart !== 2) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ACCOUNT_TO_UTXOS_INPUT, '`accountToUtxos.mintingOutputsStart` must be `2` for simplicity');
            }
            const minFee = new bignumber_js_1.default(0.001);
            const { prevouts, vin, total } = yield this.collectPrevouts(minFee);
            const deFiOut = {
                value: new bignumber_js_1.default(0),
                script: {
                    stack: [
                        jellyfish_transaction_1.OP_CODES.OP_RETURN,
                        jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ACCOUNT_TO_UTXOS(accountToUtxos)
                    ]
                },
                tokenId: 0x00
            };
            const out = {
                value: accountToUtxos.balances[0].amount,
                script: destinationScript,
                tokenId: 0x00
            };
            const change = {
                value: total,
                script: destinationScript,
                tokenId: 0x00
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [deFiOut, change, out],
                lockTime: 0x00000000
            };
            const fee = yield this.calculateFee(txn);
            change.value = total.minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
    accountToAccount(accountToAccount, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ACCOUNT_TO_ACCOUNT(accountToAccount), changeScript);
        });
    }
    /**
     * FutureSwap transaction.
     *
     * @param {SetFutureSwap} futureSwap txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    futureSwap(futureSwap, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_FUTURE_SWAP(futureSwap), changeScript);
        });
    }
}
exports.TxnBuilderAccount = TxnBuilderAccount;
//# sourceMappingURL=txn_builder_account.js.map