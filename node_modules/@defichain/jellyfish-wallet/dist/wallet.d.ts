import { WalletAccount, WalletAccountProvider } from './wallet_account';
import { WalletHdNode, WalletHdNodeProvider } from './wallet_hd_node';
/**
 * Jellyfish managed wallet.
 * WalletHdNode instance is provided by WalletHdNodeProvider.
 * WalletAccount instance for interfacing layer/upstream to service will be provided by WalletAccountProvider.
 *
 * JellyfishWallet doesn't follow BIP-44.
 */
export declare class JellyfishWallet<Account extends WalletAccount, HdNode extends WalletHdNode> {
    protected readonly nodeProvider: WalletHdNodeProvider<HdNode>;
    protected readonly accountProvider: WalletAccountProvider<Account>;
    protected readonly coinType: number;
    protected readonly purpose: number;
    static COIN_TYPE_BTC: number;
    static COIN_TYPE_DFI: number;
    /**
     * Default purpose, for Light Wallet Implementation
     */
    static PURPOSE_LIGHT_WALLET: number;
    /**
     * For Masternode creation UTXO locking
     */
    static PURPOSE_LIGHT_MASTERNODE: number;
    /**
     * For light price oracle implementation
     */
    static PURPOSE_LIGHT_PRICE_ORACLE: number;
    /**
     * @param {WalletHdNodeProvider} nodeProvider
     * @param {WalletAccountProvider} accountProvider
     * @param {number} [coinType=1129] COIN_TYPE_DFI
     * @param {number} [purpose=0] PURPOSE_LIGHT_WALLET
     */
    constructor(nodeProvider: WalletHdNodeProvider<HdNode>, accountProvider: WalletAccountProvider<Account>, coinType?: number, purpose?: number);
    /**
     * @param {number} account number to get
     * @return {WalletAccount}
     */
    get(account: number): Account;
    /**
     * @param {number} account number to get
     * @return {WalletHdNode}
     */
    deriveNode(account: number): HdNode;
    /**
     * @param {number} account number to get
     * @return {string} HD path
     */
    derivePath(account: number): string;
    /**
     * Check if account in the wallet is usable.
     * An usable account in wallet is a account that has no activity gap.
     * Account 0 (default) is always valid.
     *
     * @example 0 is the default account and usable regardless
     * @example 0,1 is usable when [0] has activity
     * @example 0,1,2 is usable when [0,1] has activity
     * @example 0,1,2,3 is usable when [0,1,2] has activity
     * @example 0,1 is usable when [0,1,3] has activity (3 should never ever has transaction in the first place)
     *
     * @param {number} account number to check if valid
     * @return Promise<boolean> usability of account
     */
    isUsable(account: number): Promise<boolean>;
    /**
     * Discover accounts that are active in managed JellyfishWallet.
     * Account are considered active if the address contains any transaction activity.
     * Default account, the first account will always get discovered regardless.
     *
     * @param {number} maxAccounts to discover
     * @return WalletAccount[] discovered
     */
    discover(maxAccounts?: number): Promise<Account[]>;
}
//# sourceMappingURL=wallet.d.ts.map