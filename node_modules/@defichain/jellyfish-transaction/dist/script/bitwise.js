"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_RESERVED2 = exports.OP_RESERVED1 = exports.OP_EQUALVERIFY = exports.OP_EQUAL = exports.OP_XOR = exports.OP_OR = exports.OP_AND = exports.OP_INVERT = void 0;
const opcode_1 = require("./opcode");
/**
 * Flips all of the bits in the input.
 */
class OP_INVERT extends opcode_1.StaticCode {
    constructor() {
        super(0x83, 'OP_INVERT');
    }
}
exports.OP_INVERT = OP_INVERT;
/**
 * Boolean AND between each bit in the inputs.
 */
class OP_AND extends opcode_1.StaticCode {
    constructor() {
        super(0x84, 'OP_AND');
    }
}
exports.OP_AND = OP_AND;
/**
 * Boolean OR between each bit in the inputs.
 */
class OP_OR extends opcode_1.StaticCode {
    constructor() {
        super(0x85, 'OP_OR');
    }
}
exports.OP_OR = OP_OR;
/**
 * Boolean exclusive OR between each bit in the inputs.
 */
class OP_XOR extends opcode_1.StaticCode {
    constructor() {
        super(0x86, 'OP_XOR');
    }
}
exports.OP_XOR = OP_XOR;
/**
 * Returns 1 if the inputs are exactly equal, 0 otherwise.
 */
class OP_EQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x87, 'OP_EQUAL');
    }
}
exports.OP_EQUAL = OP_EQUAL;
/**
 * Same as OP_EQUAL, but runs OP_VERIFY afterward.
 */
class OP_EQUALVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0x88, 'OP_EQUALVERIFY');
    }
}
exports.OP_EQUALVERIFY = OP_EQUALVERIFY;
/**
 * Transaction is invalid unless occuring in an unexecuted OP_IF branch.
 */
class OP_RESERVED1 extends opcode_1.StaticCode {
    constructor() {
        super(0x89, 'OP_RESERVED1');
    }
}
exports.OP_RESERVED1 = OP_RESERVED1;
/**
 * Transaction is invalid unless occuring in an unexecuted OP_IF branch.
 */
class OP_RESERVED2 extends opcode_1.StaticCode {
    constructor() {
        super(0x8a, 'OP_RESERVED2');
    }
}
exports.OP_RESERVED2 = OP_RESERVED2;
//# sourceMappingURL=bitwise.js.map