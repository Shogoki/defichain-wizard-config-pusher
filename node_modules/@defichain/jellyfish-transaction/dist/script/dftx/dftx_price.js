"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTokenPrice = exports.CTokenAmount = exports.CCurrencyPair = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
/**
 * Composable CurrencyPair, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CCurrencyPair extends jellyfish_buffer_1.ComposableBuffer {
    composers(cp) {
        return [
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => cp.token, v => cp.token = v),
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => cp.currency, v => cp.currency = v)
        ];
    }
}
exports.CCurrencyPair = CCurrencyPair;
/**
 * Composable TokenAmount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenAmount extends jellyfish_buffer_1.ComposableBuffer {
    composers(tp) {
        return [
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => tp.currency, v => tp.currency = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => tp.amount, v => tp.amount = v)
        ];
    }
}
exports.CTokenAmount = CTokenAmount;
/**
 * Composable TokenPrice, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenPrice extends jellyfish_buffer_1.ComposableBuffer {
    composers(sb) {
        return [
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => sb.token, v => sb.token = v),
            jellyfish_buffer_1.ComposableBuffer.compactSizeArray(() => sb.prices, v => sb.prices = v, v => new CTokenAmount(v))
        ];
    }
}
exports.CTokenPrice = CTokenPrice;
//# sourceMappingURL=dftx_price.js.map