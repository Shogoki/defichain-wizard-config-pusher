"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTokenUpdateAny = exports.CTokenUpdate = exports.CTokenCreate = exports.CTokenMint = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const dftx_balance_1 = require("./dftx_balance");
/**
 * Composable TokenMint, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenMint extends jellyfish_buffer_1.ComposableBuffer {
    composers(tm) {
        return [
            jellyfish_buffer_1.ComposableBuffer.compactSizeArray(() => tm.balances, v => tm.balances = v, v => new dftx_balance_1.CTokenBalance(v))
        ];
    }
}
exports.CTokenMint = CTokenMint;
CTokenMint.OP_CODE = 0x4d; // 'M'
CTokenMint.OP_NAME = 'OP_DEFI_TX_TOKEN_MINT';
/**
 * Composable TokenCreate, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenCreate extends jellyfish_buffer_1.ComposableBuffer {
    composers(tc) {
        return [
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => tc.symbol, v => tc.symbol = v),
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => tc.name, v => tc.name = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => tc.decimal, v => tc.decimal = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => tc.limit, v => tc.limit = v),
            jellyfish_buffer_1.ComposableBuffer.bitmask1Byte(3, () => [tc.isDAT, tc.tradeable, tc.mintable], v => {
                tc.isDAT = v[0];
                tc.tradeable = v[1];
                tc.mintable = v[2];
            })
        ];
    }
}
exports.CTokenCreate = CTokenCreate;
CTokenCreate.OP_CODE = 0x54; /// 'T'
CTokenCreate.OP_NAME = 'OP_DEFI_TX_TOKEN_CREATE';
/**
 * Composable CTokenUpdate, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenUpdate extends jellyfish_buffer_1.ComposableBuffer {
    composers(tu) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => tu.creationTx, v => tu.creationTx = v),
            jellyfish_buffer_1.ComposableBuffer.bitmask1Byte(1, () => [tu.isDAT], v => {
                tu.isDAT = v[0];
            })
        ];
    }
}
exports.CTokenUpdate = CTokenUpdate;
CTokenUpdate.OP_CODE = 0x4e; /// 'N'
CTokenUpdate.OP_NAME = 'OP_DEFI_TX_TOKEN_UPDATE';
/**
 * Composable TokenUpdateAny, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenUpdateAny extends jellyfish_buffer_1.ComposableBuffer {
    composers(tua) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => tua.creationTx, v => tua.creationTx = v),
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => tua.symbol, v => tua.symbol = v),
            jellyfish_buffer_1.ComposableBuffer.compactSizeUtf8BE(() => tua.name, v => tua.name = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => tua.decimal, v => tua.decimal = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => tua.limit, v => tua.limit = v),
            jellyfish_buffer_1.ComposableBuffer.bitmask1Byte(3, () => [tua.isDAT, tua.tradeable, tua.mintable], v => {
                tua.isDAT = v[0];
                tua.tradeable = v[1];
                tua.mintable = v[2];
            })
        ];
    }
}
exports.CTokenUpdateAny = CTokenUpdateAny;
CTokenUpdateAny.OP_CODE = 0x6e; /// 'n'
CTokenUpdateAny.OP_NAME = 'OP_DEFI_TX_TOKEN_UPDATE_ANY';
//# sourceMappingURL=dftx_token.js.map