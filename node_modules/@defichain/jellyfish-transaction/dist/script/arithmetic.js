"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_WITHIN = exports.OP_MAX = exports.OP_MIN = exports.OP_GREATERTHANOREQUAL = exports.OP_LESSTHANOREQUAL = exports.OP_GREATERTHAN = exports.OP_LESSTHAN = exports.OP_NUMNOTEQUAL = exports.OP_NUMEQUALVERIFY = exports.OP_NUMEQUAL = exports.OP_BOOLOR = exports.OP_BOOLAND = exports.OP_RSHIFT = exports.OP_LSHIFT = exports.OP_MOD = exports.OP_DIV = exports.OP_MUL = exports.OP_SUB = exports.OP_ADD = exports.OP_0NOTEQUAL = exports.OP_NOT = exports.OP_ABS = exports.OP_NEGATE = exports.OP_2DIV = exports.OP_2MUL = exports.OP_1SUB = exports.OP_1ADD = void 0;
const opcode_1 = require("./opcode");
/**
 * 1 is added to the input.
 */
class OP_1ADD extends opcode_1.StaticCode {
    constructor() {
        super(0x8b, 'OP_1ADD');
    }
}
exports.OP_1ADD = OP_1ADD;
/**
 * 1 is subtracted from the input.
 */
class OP_1SUB extends opcode_1.StaticCode {
    constructor() {
        super(0x8c, 'OP_1SUB');
    }
}
exports.OP_1SUB = OP_1SUB;
/**
 * The input is multiplied by 2. disabled.
 */
class OP_2MUL extends opcode_1.StaticCode {
    constructor() {
        super(0x8d, 'OP_2MUL');
    }
}
exports.OP_2MUL = OP_2MUL;
/**
 * The input is divided by 2. disabled.
 */
class OP_2DIV extends opcode_1.StaticCode {
    constructor() {
        super(0x8e, 'OP_2DIV');
    }
}
exports.OP_2DIV = OP_2DIV;
/**
 * The sign of the input is flipped.
 */
class OP_NEGATE extends opcode_1.StaticCode {
    constructor() {
        super(0x8f, 'OP_NEGATE');
    }
}
exports.OP_NEGATE = OP_NEGATE;
/**
 *  The input is made positive.
 */
class OP_ABS extends opcode_1.StaticCode {
    constructor() {
        super(0x90, 'OP_ABS');
    }
}
exports.OP_ABS = OP_ABS;
/**
 * If the input is 0 or 1, it is flipped. Otherwise the output will be 0.
 */
class OP_NOT extends opcode_1.StaticCode {
    constructor() {
        super(0x91, 'OP_NOT');
    }
}
exports.OP_NOT = OP_NOT;
/**
 * Returns 0 if the input is 0. 1 otherwise.
 */
class OP_0NOTEQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x92, 'OP_0NOTEQUAL');
    }
}
exports.OP_0NOTEQUAL = OP_0NOTEQUAL;
/**
 * a is added to b.
 */
class OP_ADD extends opcode_1.StaticCode {
    constructor() {
        super(0x93, 'OP_ADD');
    }
}
exports.OP_ADD = OP_ADD;
/**
 * b is subtracted from a.
 */
class OP_SUB extends opcode_1.StaticCode {
    constructor() {
        super(0x94, 'OP_SUB');
    }
}
exports.OP_SUB = OP_SUB;
/**
 * a is multiplied by b. disabled.
 */
class OP_MUL extends opcode_1.StaticCode {
    constructor() {
        super(0x95, 'OP_MUL');
    }
}
exports.OP_MUL = OP_MUL;
/**
 * a is divided by b. disabled.
 */
class OP_DIV extends opcode_1.StaticCode {
    constructor() {
        super(0x96, 'OP_DIV');
    }
}
exports.OP_DIV = OP_DIV;
/**
 * Returns the remainder after dividing a by b. disabled.
 */
class OP_MOD extends opcode_1.StaticCode {
    constructor() {
        super(0x97, 'OP_MOD');
    }
}
exports.OP_MOD = OP_MOD;
/**
 * Shifts a left b bits, preserving sign. disabled.
 */
class OP_LSHIFT extends opcode_1.StaticCode {
    constructor() {
        super(0x98, 'OP_LSHIFT');
    }
}
exports.OP_LSHIFT = OP_LSHIFT;
/**
 * Shifts a right b bits, preserving sign. disabled.
 */
class OP_RSHIFT extends opcode_1.StaticCode {
    constructor() {
        super(0x99, 'OP_RSHIFT');
    }
}
exports.OP_RSHIFT = OP_RSHIFT;
/**
 * If both a and b are not 0, the output is 1. Otherwise 0.
 */
class OP_BOOLAND extends opcode_1.StaticCode {
    constructor() {
        super(0x9a, 'OP_BOOLAND');
    }
}
exports.OP_BOOLAND = OP_BOOLAND;
/**
 * If a or b is not 0, the output is 1. Otherwise 0.
 */
class OP_BOOLOR extends opcode_1.StaticCode {
    constructor() {
        super(0x9b, 'OP_BOOLOR');
    }
}
exports.OP_BOOLOR = OP_BOOLOR;
/**
 * Returns 1 if the numbers are equal, 0 otherwise.
 */
class OP_NUMEQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x9c, 'OP_NUMEQUAL');
    }
}
exports.OP_NUMEQUAL = OP_NUMEQUAL;
/**
 * Same as OP_NUMEQUAL, but runs OP_VERIFY afterward.
 */
class OP_NUMEQUALVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0x9d, 'OP_NUMEQUALVERIFY');
    }
}
exports.OP_NUMEQUALVERIFY = OP_NUMEQUALVERIFY;
/**
 * Returns 1 if the numbers are not equal, 0 otherwise.
 */
class OP_NUMNOTEQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x9e, 'OP_NUMNOTEQUAL');
    }
}
exports.OP_NUMNOTEQUAL = OP_NUMNOTEQUAL;
/**
 * Returns 1 if a is less than b, 0 otherwise.
 */
class OP_LESSTHAN extends opcode_1.StaticCode {
    constructor() {
        super(0x9f, 'OP_LESSTHAN');
    }
}
exports.OP_LESSTHAN = OP_LESSTHAN;
/**
 * Returns 1 if a is greater than b, 0 otherwise.
 */
class OP_GREATERTHAN extends opcode_1.StaticCode {
    constructor() {
        super(0xa0, 'OP_GREATERTHAN');
    }
}
exports.OP_GREATERTHAN = OP_GREATERTHAN;
/**
 * Returns 1 if a is less than or equal to b, 0 otherwise.
 */
class OP_LESSTHANOREQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0xa1, 'OP_LESSTHANOREQUAL');
    }
}
exports.OP_LESSTHANOREQUAL = OP_LESSTHANOREQUAL;
/**
 *  Returns 1 if a is greater than or equal to b, 0 otherwise.
 */
class OP_GREATERTHANOREQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0xa2, 'OP_GREATERTHANOREQUAL');
    }
}
exports.OP_GREATERTHANOREQUAL = OP_GREATERTHANOREQUAL;
/**
 *  Returns the smaller of a and b.
 */
class OP_MIN extends opcode_1.StaticCode {
    constructor() {
        super(0xa3, 'OP_MIN');
    }
}
exports.OP_MIN = OP_MIN;
/**
 *  Returns the larger of a and b.
 */
class OP_MAX extends opcode_1.StaticCode {
    constructor() {
        super(0xa4, 'OP_MAX');
    }
}
exports.OP_MAX = OP_MAX;
/**
 *   Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.
 */
class OP_WITHIN extends opcode_1.StaticCode {
    constructor() {
        super(0xa5, 'OP_WITHIN');
    }
}
exports.OP_WITHIN = OP_WITHIN;
//# sourceMappingURL=arithmetic.js.map