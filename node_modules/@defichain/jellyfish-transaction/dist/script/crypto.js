"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_CHECKMULTISIGVERIFY = exports.OP_CHECKMULTISIG = exports.OP_CHECKSIGVERIFY = exports.OP_CHECKSIG = exports.OP_CODESEPARATOR = exports.OP_HASH256 = exports.OP_HASH160 = exports.OP_SHA256 = exports.OP_SHA1 = exports.OP_RIPEMD160 = void 0;
const opcode_1 = require("./opcode");
/**
 * The input is hashed using RIPEMD-160.
 */
class OP_RIPEMD160 extends opcode_1.StaticCode {
    constructor() {
        super(0xa6, 'OP_RIPEMD160');
    }
}
exports.OP_RIPEMD160 = OP_RIPEMD160;
/**
 * The input is hashed using SHA-1.
 */
class OP_SHA1 extends opcode_1.StaticCode {
    constructor() {
        super(0xa7, 'OP_SHA1');
    }
}
exports.OP_SHA1 = OP_SHA1;
/**
 * The input is hashed using SHA-256.
 */
class OP_SHA256 extends opcode_1.StaticCode {
    constructor() {
        super(0xa8, 'OP_SHA256');
    }
}
exports.OP_SHA256 = OP_SHA256;
/**
 * The input is hashed twice: first with SHA-256 and then with RIPEMD-160.
 */
class OP_HASH160 extends opcode_1.StaticCode {
    constructor() {
        super(0xa9, 'OP_HASH160');
    }
}
exports.OP_HASH160 = OP_HASH160;
/**
 * The input is hashed two times with SHA-256.
 */
class OP_HASH256 extends opcode_1.StaticCode {
    constructor() {
        super(0xaa, 'OP_HASH256');
    }
}
exports.OP_HASH256 = OP_HASH256;
/**
 * All of the signature checking words will only match
 * signatures to the data after the most recently-executed
 * OP_CODESEPARATOR.
 */
class OP_CODESEPARATOR extends opcode_1.StaticCode {
    constructor() {
        super(0xab, 'OP_CODESEPARATOR');
    }
}
exports.OP_CODESEPARATOR = OP_CODESEPARATOR;
/**
 * The entire transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end)
 * are hashed.
 * The signature used by OP_CHECKSIG must be a valid signature for this hash and public key.
 * If it is, 1 is returned, 0 otherwise.
 */
class OP_CHECKSIG extends opcode_1.StaticCode {
    constructor() {
        super(0xac, 'OP_CHECKSIG');
    }
}
exports.OP_CHECKSIG = OP_CHECKSIG;
/**
 * Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.
 */
class OP_CHECKSIGVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0xad, 'OP_CHECKSIGVERIFY');
    }
}
exports.OP_CHECKSIGVERIFY = OP_CHECKSIGVERIFY;
/**
 * Compares the first signature against each public key
 * until it finds an ECDSA match. Starting with the
 * subsequent public key, it compares the second
 * signature against each remaining public key until it
 * finds an ECDSA match. The process is repeated until
 * all signatures have been checked or not enough public
 * keys remain to produce a successful result.
 * All signatures need to match a public key.
 * Because public keys are not checked again if they
 * fail any signature comparison, signatures must be
 * placed in the scriptSig using the same order as their
 * corresponding public keys were placed in the
 * scriptPubKey or redeemScript.If all signatures are
 * valid, 1 is returned, 0 otherwise. Due to a bug, one
 * extra unused value is removed from the stack.
 */
class OP_CHECKMULTISIG extends opcode_1.StaticCode {
    constructor() {
        super(0xae, 'OP_CHECKMULTISIG');
    }
}
exports.OP_CHECKMULTISIG = OP_CHECKMULTISIG;
/**
 * Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.
 */
class OP_CHECKMULTISIGVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0xaf, 'OP_CHECKMULTISIGVERIFY');
    }
}
exports.OP_CHECKMULTISIGVERIFY = OP_CHECKMULTISIGVERIFY;
//# sourceMappingURL=crypto.js.map