/// <reference types="node" />
import { SmartBuffer } from 'smart-buffer';
import { OPCode } from './opcode';
/**
 * These are opcode from 1-75, 76, 77, 78.
 * Effectively this opcode carry data.
 *
 * OP_CODE      | HEX         | DESCRIPTION
 * -------------|-------------|----------------------------------------------------------------------
 * N/A          | 0x01-0x4b   | The next opcode bytes is data to be pushed onto the stack
 * OP_PUSHDATA1 | 0x4c        | The next byte contains the number of bytes to be pushed onto the stack.
 * OP_PUSHDATA2 | 0x4d        | The next 2 bytes contain the number of bytes to be pushed onto the stack in LE order.
 * OP_PUSHDATA4 | 0x4e        | The next 4 bytes contain the number of bytes to be pushed onto the stack in LE order.
 *
 * OPCODE will automatically be appended in asBuffer().
 * The constructor only accepts the bytes to be pushed in the stack.
 */
export declare class OP_PUSHDATA extends OPCode {
    /**
     * Stored as LITTLE ENDIAN hex string.
     */
    readonly hex: string;
    /**
     * @param buffer {Buffer} raw buffer to create OP_PUSHDATA with
     * @param endian {'little' | 'big'} of the buffer
     */
    constructor(buffer: Buffer, endian: 'little' | 'big');
    /**
     * @param code {number} 0x4c-0x4e for push data
     * @param buffer {SmartBuffer} smart buffer to read from
     */
    constructor(code: number, buffer: SmartBuffer);
    /**
     * Read data from buffer
     */
    private static readData;
    /**
     * Length of bytes
     */
    length(): number;
    /**
     * @return [0x01-0x4e, [>0x4b ?? length], [push data]]
     */
    asBuffer(): Buffer;
    static getLenOpBuffer(length: number): Buffer;
}
//# sourceMappingURL=data.d.ts.map