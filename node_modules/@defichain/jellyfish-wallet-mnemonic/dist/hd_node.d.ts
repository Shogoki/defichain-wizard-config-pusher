/// <reference types="node" />
import * as bip32 from 'bip32';
import { WalletHdNode, WalletHdNodeProvider } from '@defichain/jellyfish-wallet';
import { Transaction, TransactionSegWit, Vout } from '@defichain/jellyfish-transaction';
/**
 * Bip32 Options, version bytes and WIF format. Unique to each chain.
 *
 * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format
 */
export interface Bip32Options {
    bip32: {
        public: number;
        private: number;
    };
    wif: number;
}
/**
 * MnemonicHdNode implements the WalletHdNode from jellyfish-wallet.
 * MnemonicHdNode implementations is purpose and derivation agnostic.
 *
 * Prior-art:
 * - BIP32 Hierarchical Deterministic Wallets
 * - BIP39 Mnemonic code for generating deterministic keys
 * - BIP44 Multi-Account Hierarchy for Deterministic Wallets
 */
export declare class MnemonicHdNode implements WalletHdNode {
    readonly path: string;
    protected readonly rootPrivKey: Buffer;
    protected readonly chainCode: Buffer;
    protected readonly options: Bip32Options;
    constructor(path: string, rootPrivKey: Buffer, chainCode: Buffer, options: Bip32Options);
    protected deriveNode(): Promise<bip32.BIP32Interface>;
    /**
     * @return Promise<Buffer> compressed public key
     */
    publicKey(): Promise<Buffer>;
    /**
     * @return Promise<Buffer> privateKey of the WalletHdNode
     */
    privateKey(): Promise<Buffer>;
    /**
     * Sign a transaction with all prevout belong to this HdNode with SIGHASH.ALL
     * This implementation can only sign a P2WPKH, hence the implementing WalletAccount should only
     * recognize P2WPKH addresses encoded in bech32 format.
     *
     * @param {Transaction} transaction to sign
     * @param {Vout[]} prevouts of transaction to sign, ellipticPair will be mapped to current node
     * @return TransactionSegWit signed transaction ready to broadcast
     */
    signTx(transaction: Transaction, prevouts: Vout[]): Promise<TransactionSegWit>;
    /**
     * @param {Buffer} hash to sign
     * @return {Buffer} signature in DER format, SIGHASHTYPE not included
     */
    sign(hash: Buffer): Promise<Buffer>;
    /**
     * @param {Buffer} hash to verify with signature
     * @param {Buffer} derSignature of the hash in encoded with DER, SIGHASHTYPE must not be included
     * @return Promise<boolean> validity of signature of the hash
     */
    verify(hash: Buffer, derSignature: Buffer): Promise<boolean>;
}
/**
 * MnemonicHdNodeProvider data encoded as hex.
 */
export interface MnemonicProviderData {
    words: string[];
    privKey: string;
    chainCode: string;
}
/**
 * Provider that derive MnemonicHdNode from root. Uses a lite on demand derivation.
 */
export declare class MnemonicHdNodeProvider implements WalletHdNodeProvider<MnemonicHdNode> {
    private readonly data;
    private readonly options;
    private constructor();
    derive(path: string): MnemonicHdNode;
    /**
     * @param {MnemonicProviderData} data to init MnemonicHdNodeProvider
     * @param {Bip32Options} options
     */
    static fromData(data: MnemonicProviderData, options: Bip32Options): MnemonicHdNodeProvider;
    /**
     * @param {string[]} words to init MnemonicHdNodeProvider
     * @param {Bip32Options} options
     * @param {boolean} [validate=false] optionally validate mnemonic words. While BIP39 standard doesn't enforce
     * validation of words to generate the HD seed, this implementation optionally allow you to validate the BIP39 word
     * list before generating the MnemonicProviderData.
     * @throws {Error} if mnemonic sentence checksum invalid, if validate=true
     */
    static fromWords(words: string[], options: Bip32Options, validate?: boolean): MnemonicHdNodeProvider;
    /**
     * @param {string[]} words to convert into MnemonicProviderData
     * @param {Bip32Options} options
     * @param {boolean} [validate=false] optionally validate mnemonic words. While BIP39 standard doesn't enforce
     * validation of words to generate the HD seed, this implementation optionally allow you to validate the BIP39 word
     * list before generating the MnemonicProviderData.
     * @return MnemonicProviderData
     * @throws {Error} if mnemonic sentence checksum invalid, if validate=true
     */
    static wordsToData(words: string[], options: Bip32Options, validate?: boolean): MnemonicProviderData;
    /**
     * Generate a random mnemonic code of length, uses crypto.randomBytes under the hood.
     *
     * @param {number} length the sentence length of the mnemonic code
     * @param {(number) => Buffer} rng random number generation, generate random num of bytes buffer
     * @return {string[]} generated mnemonic word list, (COLD STORAGE)
     */
    static generateWords(length?: 12 | 15 | 18 | 21 | 24, rng?: (numOfBytes: number) => Buffer): string[];
}
//# sourceMappingURL=hd_node.d.ts.map