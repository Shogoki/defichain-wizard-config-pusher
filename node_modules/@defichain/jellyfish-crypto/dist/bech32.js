"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bech32 = void 0;
const bech32_1 = require("bech32");
const hash_1 = require("./hash");
/**
 * @param {Buffer} hash160 to format into bech32
 * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
 * @param {number} [version=0x00] witness version, OP_0
 * @return {string} bech32 encoded address
 * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 */
function toBech32(hash160, hrp, version = 0x00) {
    const words = bech32_1.bech32.toWords(hash160);
    words.unshift(version);
    return bech32_1.bech32.encode(hrp, words);
}
/**
 * @param {string} address to decode from bech32
 * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
 * @param {number} [version] witness version, OP_0
 * @return {Buffer} hash160 of the pubkey
 * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 */
function fromBech32(address, hrp, version) {
    const { prefix, words } = bech32_1.bech32.decode(address);
    if (hrp !== undefined && prefix !== hrp) {
        throw new Error('Invalid HRP: human readable part');
    }
    const witnessVersion = words.splice(0, 1)[0];
    if (version !== undefined && version !== witnessVersion) {
        throw new Error('Invalid witness version');
    }
    return Buffer.from(bech32_1.bech32.fromWords(words));
}
exports.Bech32 = {
    /**
     * @param {Buffer} pubKey to format into bech32
     * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
     * @param {number} [version=0x00] witness version, OP_0
     * @return {string} bech32 encoded address
     */
    fromPubKey(pubKey, hrp, version = 0x00) {
        if (pubKey.length !== 33) {
            throw new Error('InvalidPubKeyLength');
        }
        const hash = hash_1.HASH160(pubKey);
        return toBech32(hash, hrp, version);
    },
    /**
     * @param {Buffer} hash160 to format into bech32
     * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
     * @param {number} [version=0x00] witness version, OP_0
     * @return {string} bech32 encoded address
     */
    fromHash160(hash160, hrp, version = 0x00) {
        return toBech32(hash160, hrp, version);
    },
    /**
     * @param {string} address to decode from bech32
     * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
     * @param {number} [version] witness version, OP_0
     * @return {Buffer} hash160 of the pubkey
     */
    toHash160(address, hrp, version) {
        return fromBech32(address, hrp, version);
    }
};
//# sourceMappingURL=bech32.js.map