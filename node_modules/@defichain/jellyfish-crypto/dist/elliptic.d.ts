/// <reference types="node" />
/**
 * Provides the interface for an elliptic curve pair to sign and verify hash.
 * This interface is Promise based to allow async operations, this is required for hardware or network based elliptic
 * curve operation. Everything must be implemented in little endian because DeFi Blockchain uses LE.
 *
 * Signature must be encoded with Distinguished Encoding Rules.
 * @see https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
 */
export interface EllipticPair {
    /**
     * @return {Promise<Buffer>} compressed public key
     */
    publicKey: () => Promise<Buffer>;
    /**
     * Allowed to fail if EllipticPair does not provide hardware key
     * @return {Promise<Buffer>} privateKey
     */
    privateKey: () => Promise<Buffer>;
    /**
     * @param {Buffer} hash to sign
     * @return {Buffer} signature in DER format, SIGHASHTYPE not included
     * @see https://tools.ietf.org/html/rfc6979
     * @see https://github.com/bitcoin/bitcoin/pull/13666
     */
    sign: (hash: Buffer) => Promise<Buffer>;
    /**
     * @param {Buffer} hash to verify with signature
     * @param {Buffer} derSignature of the hash in encoded with DER, SIGHASHTYPE must not be included
     * @return {boolean} validity of signature of the hash
     */
    verify: (hash: Buffer, derSignature: Buffer) => Promise<boolean>;
}
export declare const Elliptic: {
    /**
     * @param {Buffer} buffer in little endian
     * @return {SECP256K1} EllipticPair
     */
    fromPrivKey(buffer: Buffer): EllipticPair;
    /**
     * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required
     * @return {SECP256K1} EllipticPair
     */
    random(rng?: (numOfBytes: number) => Buffer): EllipticPair;
};
//# sourceMappingURL=elliptic.d.ts.map