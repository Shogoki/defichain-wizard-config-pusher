"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bs58 = void 0;
const bs58_1 = __importDefault(require("bs58"));
const hash_1 = require("./hash");
function _checksum(twentyOneBytes) {
    return hash_1.SHA256(hash_1.SHA256(twentyOneBytes)).slice(0, 4);
}
/**
 * Decode a base58 address into 20 bytes data, for p2pkh and p2sh use
 * @param {string} base58 33 to 35 characters string (utf8)
 * @returns {DecodedB58} 20 bytes data + 1 byte prefix
 */
function toHash160(base58) {
    const buffer = bs58_1.default.decode(base58);
    if (buffer.length !== 25) {
        throw new Error('InvalidBase58Address');
    }
    const withPrefix = buffer.slice(0, 21);
    const checksum = buffer.slice(21, 25);
    const expectedChecksum = _checksum(withPrefix);
    if (checksum.compare(expectedChecksum) !== 0) {
        throw new Error('InvalidBase58Address');
    }
    return {
        prefix: withPrefix[0],
        buffer: withPrefix.slice(1, 21)
    };
}
/**
 * To create Base58 address using 20 bytes data + prefix, for p2pkh and p2sh use
 * @param {Buffer|string} data 20 bytes Buffer or 40 characters string
 * @param {number} prefix max = 255 = 1 byte
 * @returns Base58 address (in utf8)
 */
function fromHash160(data, prefix) {
    if (typeof data === 'string') {
        // 40 hex char string only
        if (data.length !== 40) {
            throw new Error('InvalidDataLength');
        }
    }
    else if (data.length !== 20) {
        // 20 bytes buffer only
        throw new Error('InvalidDataLength');
    }
    if (prefix > 255) {
        throw new Error('InvalidVersionPrefix');
    }
    const buffer = typeof data === 'string' ? Buffer.from(data, 'hex') : data;
    const withPrefix = Buffer.from([prefix, ...buffer]);
    const checksum = _checksum(withPrefix);
    return bs58_1.default.encode(Buffer.from([...withPrefix, ...checksum]));
}
/**
 * To create Base58 address using a raw 33 bytes (compressed) public key, for p2pkh and p2sh use
 * @param {Buffer} pubKey 33 bytes long public key
 * @param {number} prefix max = 255 = 1 byte
 * @returns {string} base58 encoded string
 */
function fromPubKey(pubKey, prefix) {
    if (pubKey.length !== 33) {
        throw new Error('InvalidPubKeyLength');
    }
    if (prefix > 255) {
        throw new Error('InvalidVersionPrefix');
    }
    const hash = hash_1.HASH160(pubKey);
    return fromHash160(hash, prefix);
}
exports.Bs58 = {
    toHash160,
    fromPubKey,
    fromHash160
};
//# sourceMappingURL=bs58.js.map