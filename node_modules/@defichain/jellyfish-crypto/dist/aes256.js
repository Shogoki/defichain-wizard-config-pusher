"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AES256 = void 0;
const randombytes_1 = __importDefault(require("randombytes"));
const browserify_aes_1 = __importDefault(require("browserify-aes"));
const hash_1 = require("./hash");
const CIPHER_ALGORITHM = 'aes-256-ctr';
/**
 * Encrypt a clear-text message using AES-256 plus a random Initialization Vector.
 * @see https://github.com/JamesMGreene/node-aes256
 *
 * @param {Buffer} key  A passphrase of any length to used to generate a symmetric session key.
 * @param {Buffer} data  The clear-text message or buffer to be encrypted.
 * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required for IV
 * @returns {Buffer}
 */
function encrypt(key, data, rng = randombytes_1.default) {
    const sha256 = hash_1.SHA256(key);
    const initVector = rng(16);
    if (initVector.length !== 16) {
        throw new Error('Initialization vector must be 16 bytes long');
    }
    const cipher = browserify_aes_1.default.createCipheriv(CIPHER_ALGORITHM, sha256, initVector);
    const ciphertext = cipher.update(data);
    return Buffer.concat([initVector, ciphertext, cipher.final()]);
}
/**
 * Decrypt an encrypted message back to clear-text using AES-256 plus a random Initialization Vector.
 * @see https://github.com/JamesMGreene/node-aes256
 *
 * @param {Buffer} key A passphrase of any length to used to generate a symmetric session key.
 * @param {Buffer} encrypted The encrypted message to be decrypted.
 * @returns {Buffer} The original plain-text message or buffer.
 */
function decrypt(key, encrypted) {
    if (encrypted.length < 17) {
        throw new Error('Provided "encrypted" must decrypt to a non-empty string or buffer');
    }
    const sha256 = hash_1.SHA256(key);
    const initVector = encrypted.slice(0, 16);
    const decipher = browserify_aes_1.default.createDecipheriv(CIPHER_ALGORITHM, sha256, initVector);
    const ciphertext = encrypted.slice(16);
    const deciphered = decipher.update(ciphertext);
    const decipherFinal = decipher.final();
    return Buffer.concat([deciphered, decipherFinal]);
}
exports.AES256 = {
    encrypt,
    decrypt
};
//# sourceMappingURL=aes256.js.map