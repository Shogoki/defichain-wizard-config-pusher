"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultState = exports.Vault = void 0;
/**
 * Loan RPCs for DeFi Blockchain
 */
class Vault {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a vault transaction.
     *
     * @param {CreateVault} vault
     * @param {string} vault.ownerAddress Any valid address or "" to generate a new address
     * @param {number} [vault.loanSchemeId] Unique identifier of the loan scheme (8 chars max). If empty, the default loan scheme will be selected
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Transaction id of the transaction
     */
    createVault(vault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('createvault', [vault.ownerAddress, vault.loanSchemeId, utxos], 'number');
        });
    }
    /**
     * Create update vault transaction.
     *
     * @param {string} vaultId
     * @param {UpdateVault} vault
     * @param {string} [vault.ownerAddress] Any valid address
     * @param {string} [vault.loanSchemeId] Unique identifier of the loan scheme (8 chars max)
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Transaction id of the transaction
     */
    updateVault(vaultId, vault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updatevault', [vaultId, vault, utxos], 'number');
        });
    }
    /**
     * Returns information about vault.
     *
     * @param {string} vaultId vault hex id
     * @param {boolean} [verbose] request verbose info (nextCollateralRatio, interestPerBlockValue, interestsPerBlock)
     * @return {Promise<VaultActive | VaultLiquidation>}
     */
    getVault(vaultId, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getvault', [vaultId, verbose], {
                collateralValue: 'bignumber',
                loanValue: 'bignumber',
                interestValue: 'bignumber',
                informativeRatio: 'bignumber',
                nextCollateralRatio: 'bignumber',
                interestPerBlockValue: 'bignumber'
            });
        });
    }
    /**
     * List all available vaults.
     *
     * @param {VaultPagination} [pagination]
     * @param {string} [pagination.start]
     * @param {boolean} [pagination.including_start]
     * @param {number} [pagination.limit=100]
     * @param {ListVaultOptions} [options]
     * @param {string} [options.ownerAddress] Address of the vault owner
     * @param {string} [options.loanSchemeId] Vault's loan scheme id
     * @param {VaultState} [options.state = VaultState.UNKNOWN] vault's state
     * @param {boolean} [options.verbose = false] true to return same information as getVault
     * @return {Promise<Vault | VaultActive | VaultLiquidation[]>} Array of objects including details of the vaults.
     */
    listVaults(pagination = {}, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listvaults', [options, pagination], {
                collateralValue: 'bignumber',
                loanValue: 'bignumber',
                interestValue: 'bignumber',
                informativeRatio: 'bignumber'
            });
        });
    }
    /**
     * Close vault
     *
     * @param {CloseVault} closeVault
     * @param {string} closeVault.vaultId Vault id
     * @param {string} closeVault.to Valid address to receive collateral tokens
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    closeVault(closeVault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('closevault', [closeVault.vaultId, closeVault.to, utxos], 'number');
        });
    }
    /**
     * Deposit to vault
     *
     * @param {DepositVault} depositVault
     * @param {string} depositVault.vaultId Vault id
     * @param {string} depositVault.from Collateral address
     * @param {string} depositVault.amount In "amount@symbol" format
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    depositToVault(depositVault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('deposittovault', [depositVault.vaultId, depositVault.from, depositVault.amount, utxos], 'number');
        });
    }
    /**
     * Withdraw from vault
     *
     * @param {WithdrawVault} withdrawVault
     * @param {string} withdrawVault.vaultId Vault id
     * @param {string} withdrawVault.to Collateral address
     * @param {string} withdrawVault.amount In "amount@symbol" format
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    withdrawFromVault(withdrawVault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('withdrawfromvault', [withdrawVault.vaultId, withdrawVault.to, withdrawVault.amount, utxos], 'number');
        });
    }
    /**
     * Bid to vault in auction
     *
     * @param {PlaceAuctionBid} placeAuctionBid
     * @param {string} placeAuctionBid.vaultId Vault Id
     * @param {index} placeAuctionBid.index Auction index
     * @param {from} placeAuctionBid.from Address to get token
     * @param {amount} placeAuctionBid.amount in "amount@symbol" format
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} The transaction id
     */
    placeAuctionBid(placeAuctionBid, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('placeauctionbid', [placeAuctionBid.vaultId, placeAuctionBid.index, placeAuctionBid.from, placeAuctionBid.amount, utxos], 'number');
        });
    }
    /**
     * List all available auctions.
     *
     * @param {AuctionPagination} pagination
     * @param {AuctionPaginationStart} [pagination.start]
     * @param {string} [pagination.start.vaultId]
     * @param {number} [pagination.start.height]
     * @param {boolean} [pagination.including_start]
     * @param {number} [pagination.limit=100]
     * @return {Promise<VaultLiquidation[]>}
     */
    listAuctions(pagination = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultPagination = {
                limit: 100
            };
            return yield this.client.call('listauctions', [Object.assign(Object.assign({}, defaultPagination), pagination)], 'number');
        });
    }
    /**
     * Returns information about auction history.
     *
     * @param {string} [owner] address or reserved word : mine / all (Default to mine)
     * @param {ListAuctionHistoryPagination} pagination
     * @param {number} [pagination.maxBlockHeight] Maximum block height
     * @param {string} [pagination.vaultId] Vault Id
     * @param {number} [pagination.index] Auction index
     * @param {number} [pagination.limit = 100]
     * @return {Promise<ListAuctionHistoryDetail>}
     */
    listAuctionHistory(owner = 'mine', pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultPagination = {
                limit: 100
            };
            return yield this.client.call('listauctionhistory', [owner, Object.assign(Object.assign({}, defaultPagination), pagination)], 'number');
        });
    }
    /**
     * Returns amount of collateral tokens needed to take an amount of loan tokens for a target collateral ratio.
     *
     * @param {string[]} loanAmounts Amount as array. Example: [ "amount@token" ]
     * @param {number} targetRatio Target collateral ratio.
     * @param {TokenPercentageSplit} [tokenSplit] Object with loans token as key and their percent split as value
     * @return {Promise<string[]>} Array of <amount@token> strings
     */
    estimateCollateral(loanAmounts, targetRatio, tokenSplit = { DFI: 1 }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('estimatecollateral', [loanAmounts, targetRatio, tokenSplit], 'number');
        });
    }
    /**
     * Returns amount of loan tokens a vault can take depending on a target collateral ratio.
     *
     * @param {string} vaultId vault hex id
     * @param {TokenPercentageSplit} tokenSplit Object with loans token as key and their percent split as value
     * @param {number} [targetRatio] Target collateral ratio. (defaults to vault's loan scheme ratio)
     * @return {Promise<string[]>} Array of `token@amount`
     */
    estimateLoan(vaultId, tokenSplit, targetRatio) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = targetRatio === undefined ? [vaultId, tokenSplit] : [vaultId, tokenSplit, targetRatio];
            return yield this.client.call('estimateloan', params, 'number');
        });
    }
    /**
     * Returns estimated vault for given collateral and loan amounts.
     *
     * @param {string[]} collateralAmounts Collateral amounts as string array. [ "amount@token" ]
     * @param {string[]} loanAmounts Loan amounts as string array. [ "amount@token" ]
     * @return {Promise<VaultEstimation>}
     */
    estimateVault(collateralAmounts, loanAmounts) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('estimatevault', [collateralAmounts, loanAmounts], {
                collateralValue: 'bignumber',
                loanValue: 'bignumber',
                informativeRatio: 'bignumber',
                collateralRatio: 'number'
            });
        });
    }
}
exports.Vault = Vault;
var VaultState;
(function (VaultState) {
    VaultState["UNKNOWN"] = "unknown";
    VaultState["ACTIVE"] = "active";
    VaultState["IN_LIQUIDATION"] = "inLiquidation";
    VaultState["FROZEN"] = "frozen";
    VaultState["MAY_LIQUIDATE"] = "mayLiquidate";
})(VaultState = exports.VaultState || (exports.VaultState = {}));
//# sourceMappingURL=vault.js.map