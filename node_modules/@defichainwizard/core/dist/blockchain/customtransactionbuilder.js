"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomTXBuilder = void 0;
const dist_1 = require("@defichain/jellyfish-transaction-builder/dist");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_api_core_1 = require("@defichain/jellyfish-api-core");
class CustomTXBuilder extends dist_1.P2WPKHTxnBuilder {
    getCustomTx(data, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            const wizardTransactionPrefix = "WzTx";
            const { prevouts, vin, total } = yield this.allPrevouts();
            const buf = Buffer.from(wizardTransactionPrefix + data);
            const op = new jellyfish_transaction_1.OP_PUSHDATA(buf, "little");
            const deFiOut = {
                value: new jellyfish_api_core_1.BigNumber(0),
                script: {
                    // stack: [op]
                    stack: [jellyfish_transaction_1.OP_CODES.OP_RETURN, jellyfish_transaction_1.OP_CODES.OP_0, op], // We need to add the OP_0 for some reason, otherwise our transaction is always rejected...
                },
                tokenId: 0x00,
            };
            const change = {
                value: total,
                script: changeScript,
                tokenId: 0x00,
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [deFiOut, change],
                lockTime: 0x00000000,
            };
            const fee = yield this.calculateFee(txn);
            change.value = total.minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
    sendTransaction(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = new jellyfish_transaction_1.CTransactionSegWit(config.txn);
            const hex = ctx.toHex();
            let start = config.initialWaitTime;
            //TODO: Maybe we can make this code more readable. As clever as it is, might be hard to understand
            yield new Promise((resolve, error) => {
                let intervalID;
                const send = () => {
                    config.client.rawtx
                        .send({ hex: hex })
                        .then((txId) => {
                        if (intervalID !== undefined) {
                            clearInterval(intervalID);
                        }
                        resolve(txId);
                    })
                        .catch((e) => {
                        if (start >= config.waitTime * config.retries) {
                            if (intervalID !== undefined) {
                                clearInterval(intervalID);
                            }
                            error(e);
                        }
                    });
                };
                setTimeout(() => {
                    send();
                    intervalID = setInterval(() => {
                        start += config.waitTime;
                        send();
                    }, config.waitTime);
                }, config.initialWaitTime);
            });
            return ctx;
        });
    }
}
exports.CustomTXBuilder = CustomTXBuilder;
