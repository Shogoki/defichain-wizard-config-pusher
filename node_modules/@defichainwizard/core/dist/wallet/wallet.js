"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const storage_1 = require("../utils/storage");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const whale_api_client_1 = require("@defichain/whale-api-client");
const configuration_1 = require("../utils/configuration");
const loan_1 = require("@defichain/whale-api-client/dist/api/loan");
const dfifactory_1 = require("../blockchain/dfifactory");
const custom_transactions_1 = require("@defichainwizard/custom-transactions");
/**
 * The DFIWallet offers all functions to interact with the DFIWallet.
 */
class Wallet {
    /**
     * The DFI Wallet Address and the network is needed to instantiate the wallet.
     *
     * @param address the DFI wallet address
     * @param network the network as string (e.g. mainnet, testnet)
     */
    constructor(address, network = "mainnet") {
        this.storage = new storage_1.DFIStorageUtility();
        this.storage.storeAddress(address);
        this.storage.storeNetwork(network);
        this.network = network.toLowerCase() === "mainnet" ? jellyfish_network_1.MainNet : jellyfish_network_1.TestNet;
        this.client = new whale_api_client_1.WhaleApiClient({
            url: configuration_1.OCEAN_URL,
            version: configuration_1.OCEAN_VERSION,
            network: this.network.name,
        });
    }
    /**
     * Returns the current {@link WhaleApiClient}.
     * @returns The current {@link WhaleApiClient}.
     */
    getClient() {
        return this.client;
    }
    /**
     * Returns the network used for this wallet ('mainnet', 'testnet',...) as string.
     * @returns The network used for this wallet as string.
     */
    getNetworkAsString() {
        return this.storage.getNetwork();
    }
    /**
     * Returns the {@link Network} used for this wallet ('mainnet', 'testnet',...).
     * @returns The network used for this wallet.
     */
    getNetwork() {
        return this.network;
    }
    /**
     * Returns the address used for this wallet. Usually starts with 'df1...'.
     * @returns The address used for this wallet.
     */
    getAddress() {
        return this.storage.getAddress();
    }
    /**
     * Returns a certain vault used for this wallet.
     * @param id The ID of the vault to be used.
     * @returns The vault used for this wallet.
     */
    getVault(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // get vaults and filter active ones
            const dfiVaults = (yield this.client.address.listVault(this.getAddress()))
                .filter(this.isActive)
                .filter((vault) => vault.vaultId === id);
            if (dfiVaults.length === 0)
                throw new Error(`No vault with given ID found - ID: ${id}.`);
            return dfiVaults[0];
        });
    }
    /**
     * Returns the current vault.
     * @returns The vault currently stored vault to be used for management.
     */
    getCurrentVault() {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.storage.getCurrentVault();
            if (!id)
                throw new Error("You tried to get the current vault, but no stored vault was found!");
            return this.getVault(id);
        });
    }
    /**
     * Stores the current vault to be managed by the wizard.
     * @param id The id of the vault to be used as current vault.
     */
    setCurrentVault(id) {
        this.storage.storeCurrentVault(id);
    }
    /**
     * Sends a custom transaction to your address, so that the backend can pick it up.
     * @param message The {@link CustomMessage} to send
     * @param seed The seed object.
     * @param passphrase The passphrase to decrypt the seed.
     * @returns the transcation id.
     */
    sendTransaction(message, seed, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = {
                client: this.client,
                account: yield dfifactory_1.DFIFactory.getAccount(this, seed, passphrase),
                network: this.network,
                passphrase: yield seed.asArray(passphrase),
            };
            return yield new custom_transactions_1.Transaction(config).send(message);
        });
    }
    /**
     * Returns {@link LoanVaultActive} if vault is in active state.
     *
     * Info: This is an internal type guard to make sure that only active vaults will be displayed to the user.
     *
     * @param vault the vault to be checked
     * @returns {@link LoanVaultActive} if vault is in active state.
     */
    isActive(vault) {
        return vault.state === loan_1.LoanVaultState.ACTIVE;
    }
    /**
     * Returns all vaults that have been created in this wallet.
     * @returns All vaults found for this wallet.
     */
    getVaults() {
        return __awaiter(this, void 0, void 0, function* () {
            // get vaults and filter active ones
            const dfiVaults = (yield this.client.address.listVault(this.getAddress())).filter(this.isActive);
            let vaults = [];
            for (let vault of dfiVaults) {
                vaults.push(vault);
            }
            return vaults;
        });
    }
    /**
     * Returns a list of tokens stored in the wallet.
     *
     * @returns An array of tokens that are stored in the wallet.
     */
    listTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokens = yield this.client.address.listToken(this.getAddress(), 200);
            const returnTokens = [];
            tokens.map((token) => {
                returnTokens.push(token);
            });
            return returnTokens;
        });
    }
    /**
     * Returns the UTXO Balance of the wallet.
     * @returns The UTXO Balance of the wallet.
     */
    getUTXOBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this.client.address.getBalance(this.getAddress());
            return Number(balance);
        });
    }
}
exports.Wallet = Wallet;
