"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const whale_api_wallet_1 = require("@defichain/whale-api-wallet");
const customtransactionbuilder_1 = require("../blockchain/customtransactionbuilder");
const compressor_1 = require("../utils/compressor");
const encryptor_1 = require("../utils/encryptor");
const helpers_1 = require("../utils/helpers");
/**
 * The transaction class that offers all methods to send a
 * transaction or to read the custom message from a transaction.
 */
class Transaction {
    /**
     * The constructor takes the transaction configuration {@link TransactionConfig}.
     *
     * @param config The transaction configuration object
     */
    constructor(config) {
        this.client = config.client;
        this.account = config.account;
        this.network = config.network;
        this.passphrase = config.passphrase;
    }
    /**
     * Will compress, encrypt and send the given custom message.
     * @param message The {@link CustomMessage} or {@link Version} to send.
     * @returns the transaction id
     */
    send(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendCustomMessage(this.compressAndEncryptMessage(message), (0, helpers_1.isVersionMessage)(message)
                ? helpers_1.WIZARD_TRANSACTION_VERSION_PREFIX
                : helpers_1.WIZARD_TRANSACTION_CONFIG_PREFIX);
        });
    }
    /**
     * Retrieves the last config for this bot. This could either be a {{@link CustomMessage}} or a {{@link Version}}.
     * @returns The latest transaction found for this address
     */
    /*
    async findLastBlockchainConfiguration(): Promise<DecryptedConfig | null> {
      const address = await this.account.getAddress();
  
      // read all transactions for the configured address and only keep VOUT transactions
      const myVoutTXs = (
        await this.client.address.listTransaction(address, 99999999)
      ).filter((tx) => tx.type === "vout");
  
      // loop over all VOUT transactions
      for (const transaction of myVoutTXs) {
        // read details of transaction
        const transactionVouts = await this.client.transactions.getVouts(transaction.txid)
        );
      }
  
      return null;
    }
    */
    /**
     * Takes the compressed and encrypted message from the transaction and returns the
     * decompressed and decrypted {@link CustomMessage}.
     *
     * @param message The message as extracted from the transaction.
     * @returns The custom message.
     */
    getCustomMessage(message) {
        return this.decryptAndDecompressMessage(message);
    }
    /**
     * Takes the compressed and encrypted message as string and sends it.
     * @param message The message as prepared string to send.
     * @returns
     */
    sendCustomMessage(message, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const feeRateProvider = new whale_api_wallet_1.WhaleFeeRateProvider(this.client);
            const prevoutProvider = new whale_api_wallet_1.WhalePrevoutProvider(this.account, 200);
            const builder = new customtransactionbuilder_1.CustomTXBuilder(feeRateProvider, prevoutProvider, {
                get: () => this.account,
            }, this.network);
            const txn = yield builder.getCustomTx(message, yield this.account.getScript(), prefix);
            const transaction = yield builder.sendTransaction({
                txn,
                initialWaitTime: 2000,
                waitTime: 5000,
                retries: 3,
                client: this.client,
            }); //
            if (transaction.vin.length > 0)
                return new String(transaction.vin[0].txid).toString();
            throw Error("No transaction ID received!");
        });
    }
    /**
     * Takes the {@link CustomMessage} and compresses and encrypts it.
     *
     * @param message The {@link CustomMessage} to compress and encrypt
     * @returns the compressed and encrypted message as string
     */
    compressAndEncryptMessage(message) {
        // first we will compress the message
        const compressedData = compressor_1.MessageCompressor.compress(message);
        // now we will encrypt the message
        return encryptor_1.MessageEncryptor.encrypt(compressedData, this.passphrase);
    }
    /**
     * Takes the compressed and encrypted string from the transaction and returns the {@link CustomMessage}.
     *
     * @param message The compressed and encrypted string from the transaction
     * @returns the uncompressed and decrypted {@link CustomMessage}
     */
    decryptAndDecompressMessage(message) {
        // first we will decrypt the message
        const decryptedData = encryptor_1.MessageEncryptor.decrypt(message, this.passphrase);
        // now we will decompress the message
        return compressor_1.MessageCompressor.decompress(decryptedData);
    }
}
exports.Transaction = Transaction;
