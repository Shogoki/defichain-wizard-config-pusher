import { WhaleApiClient } from "@defichain/whale-api-client";
import { WhaleWalletAccount } from "@defichain/whale-api-wallet";
import { Network } from "@defichain/jellyfish-network";
import { CustomMessage } from "./message";
import { Version } from "./version";
interface DFITransaction {
    send: (message: CustomMessage) => void;
}
interface DecryptedConfig {
    blockTime: number;
    config: CustomMessage;
}
/**
 * The options that must be passed in order to create a transaction.
 */
interface TransactionConfig {
    client: WhaleApiClient;
    account: WhaleWalletAccount;
    network: Network;
    passphrase: string[];
}
/**
 * The transaction class that offers all methods to send a
 * transaction or to read the custom message from a transaction.
 */
declare class Transaction implements DFITransaction {
    private readonly client;
    private readonly account;
    private readonly network;
    private readonly passphrase;
    /**
     * The constructor takes the transaction configuration {@link TransactionConfig}.
     *
     * @param config The transaction configuration object
     */
    constructor(config: TransactionConfig);
    /**
     * Will compress, encrypt and send the given custom message.
     * @param message The {@link CustomMessage} or {@link Version} to send.
     * @returns the transaction id
     */
    send(message: CustomMessage | Version): Promise<string>;
    /**
     * Retrieves the last config for this bot. This could either be a {{@link CustomMessage}} or a {{@link Version}}.
     * @returns The latest transaction found for this address
     */
    /**
     * Takes the compressed and encrypted message from the transaction and returns the
     * decompressed and decrypted {@link CustomMessage}.
     *
     * @param message The message as extracted from the transaction.
     * @returns The custom message.
     */
    getCustomMessage(message: string): CustomMessage | Version;
    /**
     * Takes the compressed and encrypted message as string and sends it.
     * @param message The message as prepared string to send.
     * @returns
     */
    private sendCustomMessage;
    /**
     * Takes the {@link CustomMessage} and compresses and encrypts it.
     *
     * @param message The {@link CustomMessage} to compress and encrypt
     * @returns the compressed and encrypted message as string
     */
    private compressAndEncryptMessage;
    /**
     * Takes the compressed and encrypted string from the transaction and returns the {@link CustomMessage}.
     *
     * @param message The compressed and encrypted string from the transaction
     * @returns the uncompressed and decrypted {@link CustomMessage}
     */
    private decryptAndDecompressMessage;
}
export { Transaction, TransactionConfig, DecryptedConfig };
