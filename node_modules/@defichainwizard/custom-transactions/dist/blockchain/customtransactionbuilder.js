"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomTXBuilder = void 0;
const dist_1 = require("@defichain/jellyfish-transaction-builder/dist");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_api_core_1 = require("@defichain/jellyfish-api-core");
const helpers_1 = require("../utils/helpers");
const async_await_retry_1 = __importDefault(require("async-await-retry"));
/**
 * The Custom Transaction Builder, that actually builds the transaction based on the passed data.
 */
class CustomTXBuilder extends dist_1.P2WPKHTxnBuilder {
    constructor() {
        super(...arguments);
        /**
         * Sends the actual RAW transaction
         *
         * @param rawTx The RAW Tx object to send
         * @param hex the object with the hex data
         * @returns The transaction id
         */
        this.sendRawTx = (rawtx, hex) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    const tx = rawtx.send(hex);
                    resolve(tx);
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    getCustomTx(data, changeScript, prefix = helpers_1.WIZARD_TRANSACTION_CONFIG_PREFIX) {
        return __awaiter(this, void 0, void 0, function* () {
            const { prevouts, vin, total } = yield this.allPrevouts();
            const buf = Buffer.from(prefix + data);
            const op = new jellyfish_transaction_1.OP_PUSHDATA(buf, "little");
            const deFiOut = {
                value: new jellyfish_api_core_1.BigNumber(0),
                script: {
                    stack: [jellyfish_transaction_1.OP_CODES.OP_RETURN, jellyfish_transaction_1.OP_CODES.OP_0, op],
                },
                tokenId: 0x00,
            };
            const change = {
                value: total,
                script: changeScript,
                tokenId: 0x00,
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [deFiOut, change],
                lockTime: 0x00000000,
            };
            const fee = yield this.calculateFee(txn);
            change.value = total.minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
    /**
     * Triggers the RAW transaction.
     *
     * First waits some time before it starts (config.initialWaitTime) and then tries several times (config.retries) until successful.
     *
     * Will throw error if it failed after the defined number of retries.
     */
    sendTransaction(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = new jellyfish_transaction_1.CTransactionSegWit(config.txn);
            // first wait for config.initialWaitTime before doing anything
            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield (0, async_await_retry_1.default)(this.sendRawTx, [config.client.rawtx, { hex: ctx.toHex() }], {
                        retriesMax: config.retries,
                        interval: config.waitTime,
                        exponential: true,
                        factor: 3,
                    });
                }
                catch (err) {
                    throw Error(`Could not send transaction after ${config.retries} retries. ERR: ${err}.`);
                }
            }), config.initialWaitTime);
            return ctx;
        });
    }
}
exports.CustomTXBuilder = CustomTXBuilder;
